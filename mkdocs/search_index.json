{
    "docs": [
        {
            "location": "/", 
            "text": "UGRID Conventions\n\uf0c1\n\n\nIntroduction\n\uf0c1\n\n\nThis page describes a proposal for storing unstructured (or flexible mesh) model data in the Unidata Network Common Data Form (NetCDF) file. Our focus is on data for environmental applications and hence we start from the \nClimate \n Forecast (CF) Metadata Conventions\n. The CF Conventions have been the standard in climate research for many years, and are  being adopted by others as the metadata standard (e.g. \nNASA\n,\nOpen Geospatial Consortium\n). The CF conventions allow you to provide the geospatial and temporal coordinates for scientific data, but currently assumes that the horizontal topology may be inferred from the i,j indices of structured grids.  This proposal adds conventions for specifying the topology for unstructured (e.g. triangular) grids.  \n\n\nIn its most basic form unstructured data may be stored as data defined at a series of points, the CF-conventions are then sufficient. However, it is often useful or even necessary to also know the topology of the underlying unstructured mesh: is it a one dimensional (1D) network, a two dimensional (2D) triangular mesh or more flexible mixed triangle/quadrilateral mesh, a 2D mesh with vertical layers, or a fully unstructured three dimensional (3D) mesh. This document describes the attribute conventions for storing the mesh topology and for associating variables with (specific locations on) the mesh topology. The conventions have been designed to store the output data of a combined 1D-2D-3D flow model with staggered data, but the metadata for a simple 1D network or 2D triangular mesh doesn\nt suffer from the genericity needed for the most complex models.\n\n\nDue to the complexity in unstructured mesh models, some concepts have not yet been worked out in this version.\n\n\nKnown issues left for future versions include: \n\n adaptive mesh topology (this could be supported by defining a \ntime_concatenation\n attribute for a time-series of mesh topologies)\n\n higher order element data; for an idea how such data could be stored see this other \nproposal\n.\n\n subgrid data; the NetCDF pages by the Bundesanstalt f\u00fcr Wasserbau (BAW) contain some proposals on this topic (\nsee their pages (in German)\n).\n\n 3D fully unstructured meshes (some concepts are included here, but still somewhat limited in scope).\n\n multiply-connected domains\n\n ghost elements\n\n\nTopology\n\uf0c1\n\n\nNaming conventions for geometrical elements\n\uf0c1\n\n\nInspired by Wikipedia\ns definition of \nnetwork topology\n, we define the mesh topology here as the interconnection of various geometrical elements of the mesh. The pure interconnectivity is independent of georeferencing the individual geometrical elements, but for the practical applications for which we are defining this CF extension, we\nll always add coordinate data. Within a mesh, one can distinguish 0-, 1-, 2- and 3-dimensional elements. We need some names to identify these four types of elements; after discussion we propose the following names:\n\n\n\n\n\n\n\n\nDimensionality\n\n\nProposed Name\n\n\nComments\n\n\n\n\n\n\n\n\n\n\n0\n\n\nnode\n\n\nA point, a coordinate pair or triplet: the most basic element of the topology. The word \nnode\n seems to be more commonly used than the alternative \nvertex\n.\n\n\n\n\n\n\n1\n\n\nedge\n\n\nA line or curve bounded by two nodes.\n\n\n\n\n\n\n2\n\n\nface\n\n\nA plane or surface enclosed by a set of edges. In a 2D horizontal application one may consider the word \npolygon\n, but in the hierarchy of elements the word \nface\n is most common.\n\n\n\n\n\n\n3\n\n\nvolume\n\n\nA volume enclosed by a set of faces.  The alternative word \ncell\n was considered, but \ncell\n is often used in the community to describe 2 dimensional structures.\n\n\n\n\n\n\n\n\nIn favor of simpler code for interpreting compliant files, we have dropped to use of the \nlocations\n attribute which allowed the user to specify his/her own names for nodes, edges, faces and volumes.\n\n\n1D network topology\n\uf0c1\n\n\nThe topology information is stored as attributes to a dummy variable (in the example below called \nMesh1\n) with \ncf_role\n mesh_topology.\n\n\n\n\n\n\n\n\nRequired topology attributes\n\n\nValue\n\n\n\n\n\n\n\n\n\n\ncf_role\n\n\nmesh_topology\n\n\n\n\n\n\ntopology_dimension\n\n\n1\n\n\n\n\n\n\nnode_coordinates\n\n\n\n\n\n\n\n\nedge_node_connectivity\n\n\n\n\n\n\n\n\nOptional attributes\n\n\n\n\n\n\n\n\nedge_coordinates\n\n\n\n\n\n\n\n\n\n\nThe attribute \ntopology_dimension\n indicates the highest dimensionality of the geometric elements; for a 1D network this should be 1. The attribute \nnode_coordinates\n points to the auxiliary coordinate variables representing the node locations (latitude, longitude, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute \nedge_node_connectivity\n points to an index variable identifying for every edge to the indices of its begin and end nodes. The connectivity array will thus be a matrix of size nEdges x 2. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a \nstart_index\n attribute to the index variable (i.e. Mesh1_edge_nodes in the example below). Consistent with the CF-conventions \ncompression\n option, the connectivity indices are 0-based by default.\n\n\nThe option to support both 0- and 1-based indexing was introduced to be able to support existing files with 1-based index tables using ncML.\n See \nthis section on zero or one-based indexing\n for more details. \n\n\nThe mesh_topology may optionally include an \nedge_coordinates\n attribute which points to the auxiliary coordinate variables associated with the characteristic location of the edge (commonly the midpoint). These auxiliary coordinate variables will have length nEdges, and may have in turn a \nbounds\n attribute that specifies the bounding coordinates of the edge (thereby duplicating the data in the \nnode_coordinates\n variables).\n\n\nThis use of the \nbounds\n attribute is consistent with the CF-convention on the use of \nbounds\n for multi-dimensional coordinate variables with p-sided cells, but it may not strictly be supported by the CF-convention right now.\n\n\n\n\nExample:\n\n\ndimensions:\nnMesh1_node = 5 ; // nNodes\nnMesh1_edge = 4 ; // nEdges\n\nTwo = 2;\n\nvariables:\n// Mesh topology\ninteger Mesh1 ;\nMesh1:cf_role = \nmesh_topology\n ;\nMesh1:long_name = \nTopology data of 1D network\n ;\nMesh1:topology_dimension = 1 ;\nMesh1:node_coordinates = \nMesh1_node_x Mesh1_node_y\n ;\nMesh1:edge_node_connectivity = \nMesh1_edge_nodes\n ;\nMesh1:edge_coordinates = \nMesh1_edge_x Mesh1_edge_y\n ; // optional attribute\ninteger Mesh1_edge_nodes(nMesh1_edge, Two) ;\nMesh1_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh1_edge_nodes:long_name = \nMaps every edge/link to the two nodes that it connects.\n ;\nMesh1_edge_nodes:start_index = 1 ;\n\n// Mesh node coordinates\ndouble Mesh1_node_x(nMesh1_node) ;\nMesh1_node_x:standard_name = \nlongitude\n ;\nMesh1_node_x:long_name = \nLongitude of 1D network nodes.\n ;\nMesh1_node_x:units = \ndegrees_east\n ;\ndouble Mesh1_node_y(nMesh1_node) ;\nMesh1_node_y:standard_name = \nlatitude\n ;\nMesh1_node_y:long_name = \nLatitude of 1D network nodes.\n ;\nMesh1_node_y:units = \ndegrees_north\n ;\n\n// Optional mesh edge coordinate variables\ndouble Mesh1_edge_x(nMesh1_edge) ;\nMesh1_edge_x:standard_name = \nlongitude\n ;\nMesh1_edge_x:long_name = \nCharacteristic longitude of 1D network edge (e.g. midpoint of the edge).\n ;\nMesh1_edge_x:units = \ndegrees_east\n ;\nMesh1_edge_x:bounds = \nMesh1_edge_xbnds\n ;\ndouble Mesh1_edge_y(nMesh1_edge) ;\nMesh1_edge_y:standard_name = \nlatitude\n ;\nMesh1_edge_y:long_name = \nCharacteristic latitude of 1D network edge (e.g. midpoint of the edge).\n ;\nMesh1_edge_y:units = \ndegrees_north\n ;\nMesh1_edge_y:bounds = \nMesh1_edge_ybnds\n ;\ndouble Mesh1_edge_xbnds(nMesh1_edge,Two) ;\nMesh1_edge_xbnds:standard_name = \nlongitude\n ;\nMesh1_edge_xbnds:long_name = \nLongitude bounds of 1D network edge (i.e. begin and end longitude).\n ;\nMesh1_edge_xbnds:units = \ndegrees_east\n ;\ndouble Mesh1_edge_ybnds(nMesh1_edge,Two) ;\nMesh1_edge_ybnds:standard_name = \nlatitude\n ;\nMesh1_edge_ybnds:long_name = \nLatitude bounds of 1D network edge (i.e. begin and end latitude).\n ;\nMesh1_edge_ybnds:units = \ndegrees_north\n ;\n\n\n\n\n2D triangular mesh topology\n\uf0c1\n\n\nThe topology information is stored as attributes to a dummy variable (in the example below called \nMesh2\n) with \ncf_role\n mesh_topology.\n\n\n\n\n\n\n\n\nRequired topology attributes\n\n\nValue\n\n\n\n\n\n\n\n\n\n\ncf_role\n\n\nmesh_topology\n\n\n\n\n\n\ntopology_dimension\n\n\n2\n\n\n\n\n\n\nnode_coordinates\n\n\n\n\n\n\n\n\nface_node_connectivity\n\n\n\n\n\n\n\n\nOptionally required attributes\n*\n\n\n\n\n\n\n\n\nedge_node_connectivity\n\n\n\n\n\n\n\n\nOptional attributes \n\n\n\n\n\n\n\n\nface_edge_connectivity\n\n\n\n\n\n\n\n\nface_face_connectivity\n\n\n\n\n\n\n\n\nboundary_node_connectivity\n\n\n\n\n\n\n\n\nface_coordinates\n\n\n\n\n\n\n\n\nedge_coordinates\n\n\n\n\n\n\n\n\n\n\n*The \nOptionally required\n attribute \nedge_node_connectivity\n is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges).\n\n\nThe attribute \ntopology_dimension\n indicates the highest dimensionality of the geometric elements; for a 2-dimensional (triangular) mesh this should be 2. The attribute \nnode_coordinates\n points to the auxiliary coordinate variables representing the node locations (latitude, longitude, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute \nface_node_connectivity\n points to an index variable identifying for every face (here consistently triangle) the indices of its three corner nodes. The corner nodes should be specified in anticlockwise (also referred to as counterclockwise) direction as viewed from above (consistent with the CF-convention for \nbounds\n of p-sided cells. The connectivity array will thus be a matrix of size nFaces x 3. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a \nstart_index\n attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions \ncompression\n option, the connectivity indices are 0-based by default. See \nthis section on zero or one-based indexing\n for more details.\n\n\nIn case you want to define variables on the edges of the triangular mesh topology you need to specify the \nedge_node_connectivity\n attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of \nedge_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default.  Since it does not apply to edges globally, specifying the \nboundary_node_connectivity\n attribute described below does not (in and of itself) necessitate the need to specify the \nedge_node_connectivity\n attribute too.\n\n\nOptionally the topology may have the following attributes:\n\n \nface_edge_connectivity\n pointing to an index variable identifying for every face (here consistently triangle) the indices of its three edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will thus be a matrix of size nFaces x 3. Again the indexing convention of \nface_edge_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default.\n\n \nface_face_connectivity\n pointing to an index variable identifying all faces (here consistently triangle) that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x 3 with a flag to note if the region \nout of mesh\n abuts an edge of a given face. Again the indexing convention of \nface_face_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_face_links in the example below) and 0-based indexing is the default.\n\n \nboundary_node_connectivity\n pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects.  Again the indexing convention of \nboundary_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default.  Although constructed of edges, boundaries represent a different quantity than general edge data and thus the \nboundary_node_connectivity\n attribute may be specified independent of \nedge_node_connectivity\n.  Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1.\n\n \nface_coordinates\n and/or \nedge_coordinates\n pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a \nbounds\n attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the \nnode_coordinates\n variables).\n\n\n\n\nExample:\n\n\ndimensions:\nnMesh2_node = 4 ; // nNodes\nnMesh2_edge = 5 ; // nEdges\nnMesh2_face = 2 ; // nFaces\n\nTwo = 2 ;\nThree = 3 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\nMesh2:cf_role = \nmesh_topology\n ;\nMesh2:long_name = \nTopology data of 2D unstructured mesh\n ;\nMesh2:topology_dimension = 2 ;\nMesh2:node_coordinates = \nMesh2_node_x Mesh2_node_y\n ;\nMesh2:face_node_connectivity = \nMesh2_face_nodes\n ;\nMesh2:edge_node_connectivity = \nMesh2_edge_nodes\n ; // attribute required if variables will be defined on edges\nMesh2:edge_coordinates = \nMesh2_edge_x Mesh2_edge_y\n ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_coordinates = \nMesh2_face_x Mesh2_face_y\n ; // optional attribute\nMesh2:face_edge_connectivity = \nMesh2_face_edges\n ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_face_connectivity = \nMesh2_face_links\n ; // optional attribute\ninteger Mesh2_face_nodes(nMesh2_face, Three) ;\nMesh2_face_nodes:cf_role = \nface_node_connectivity\n ;\nMesh2_face_nodes:long_name = \nMaps every triangular face to its three corner nodes.\n ;\nMesh2_face_nodes:start_index = 1 ;\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\nMesh2_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh2_edge_nodes:long_name = \nMaps every edge to the two nodes that it connects.\n ;\nMesh2_edge_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, Three) ;\nMesh2_face_edges:cf_role = \nface_edge_connectivity\n ;\nMesh2_face_edges:long_name = \nMaps every triangular face to its three edges.\n ;\nMesh2_face_edges:start_index = 1 ;\ninteger Mesh2_face_links(nMesh2_face, Three) ;\nMesh2_face_links:cf_role = \nface_face_connectivity\n ;\nMesh2_face_links:long_name = \nIndicates which other faces neighbor each face.\n ;\nMesh2_face_links:start_index = 1 ;\nMesh2_face_links:flag_values = -1 ;\nMesh2_face_links:flag_meanings = \nout_of_mesh\n ;\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name = \nlongitude\n ;\nMesh2_node_x:long_name = \nLongitude of 2D mesh nodes.\n ;\nMesh2_node_x:units = \ndegrees_east\n ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name = \nlatitude\n ;\nMesh2_node_y:long_name = \nLatitude of 2D mesh nodes.\n ;\nMesh2_node_y:units = \ndegrees_north\n ;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name = \nlongitude\n ;\nMesh2_face_x:long_name = \nCharacteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).\n ;\nMesh2_face_x:units = \ndegrees_east\n ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name = \nlatitude\n ;\nMesh2_face_y:long_name = \nCharacteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).\n ;\nMesh2_face_y:units = \ndegrees_north\n ;\ndouble Mesh2_edge_x(nMesh2_edge) ;\nMesh2_edge_x:standard_name = \nlongitude\n ;\nMesh2_edge_x:long_name = \nCharacteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh2_edge_x:units = \ndegrees_east\n ;\ndouble Mesh2_edge_y(nMesh2_edge) ;\nMesh2_edge_y:standard_name = \nlatitude\n ;\nMesh2_edge_y:long_name = \nCharacteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh2_edge_y:units = \ndegrees_north\n ;\n\n\n\n\n2D flexible mesh (mixed triangles, quadrilaterals, etc.) topology\n\uf0c1\n\n\nThe case of a 2D mesh with mixed face sizes is identical to the 2D triangular mesh discussed above with the exception that not all faces have the same number of nodes. To support this variability we may use in the future a ragged array, but here we propose to use _FillValue to indicate faces with smaller number of nodes than the arrays allow.\n\n\nThe topology information is stored as attributes to a dummy variable (in the example below called \nMesh2\n) with \ncf_role\n mesh_topology.\n\n\n\n\n\n\n\n\nRequired topology attributes\n\n\nValue\n\n\n\n\n\n\n\n\n\n\ncf_role\n\n\nmesh_topology\n\n\n\n\n\n\ntopology_dimension\n\n\n2\n\n\n\n\n\n\nnode_coordinates\n\n\n\n\n\n\n\n\nface_node_connectivity\n\n\n\n\n\n\n\n\nOptionally required attributes\n*\n\n\n\n\n\n\n\n\nedge_node_connectivity\n\n\n\n\n\n\n\n\nOptional attributes\n\n\n\n\n\n\n\n\nface_edge_connectivity\n\n\n\n\n\n\n\n\nface_face_connectivity\n\n\n\n\n\n\n\n\nboundary_node_connectivity\n\n\n\n\n\n\n\n\nface_coordinates\n\n\n\n\n\n\n\n\nedge_coordinates\n\n\n\n\n\n\n\n\n\n\n*The \nOptionally required\n attribute \nedge_node_connectivity\n is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges).\n\n\nThe attribute \ntopology_dimension\n indicates the highest dimensionality of the geometric elements; for a 2-dimensional mesh this should be 2. The attribute \nnode_coordinates\n points to the auxiliary coordinate variables representing the node locations (latitude, longitude, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute \nface_node_connectivity\n points to an index variable identifying for every face the indices of its corner nodes. The corner nodes should be specified in anticlockwise direction as viewed from above (consistent with the CF-convention for \nbounds\n of p-sided cells. The connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace; if a face has less corner nodes than MaxNumNodesPerFace then the last node indices shall be equal to \n_FillValue\n (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a \nstart_index\n attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions \ncompression\n option, the connectivity indices are 0-based by default. See \nthis section on zero or one-based indexing\n for more details.\n\n\nIn case you want to define variables on the edges of the 2D mesh topology you need to specify the \nedge_node_connectivity\n attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of \nedge_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default. Since it does not apply to edges globally, specifying the \nboundary_node_connectivity\n attribute described below does not (in and of itself) necessitate the need to specify the \nedge_node_connectivity\n attribute too.\n\n\nOptionally the topology may have the following attributes:\n\n \nface_edge_connectivity\n pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to \n_FillValue\n, and the indexing convention of \nface_edge_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default.\n\n \nface_face_connectivity\n pointing to an index variable identifying all faces that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x MaxNumNodesPerFace with a flag to note if the region \nout of mesh\n abuts an edge of a given face. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last face (column) indices shall be equal to \n_FillValue\n, and the indexing convention of \nface_face_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_face_links in the example below) and 0-based indexing is the default.\n\n \nboundary_node_connectivity\n pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects.  Again the indexing convention of \nboundary_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default.  Although constructed of edges, boundaries represent a different quantity than general edge data and thus the \nboundary_node_connectivity\n attribute may be specified independent of \nedge_node_connectivity\n.  Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1.\n\n \nface_coordinates\n and/or \nedge_coordinates\n pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a \nbounds\n attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the \nnode_coordinates\n variables).\n\n\nThe use of \n_FillValue\n to indicate faces with less nodes than MaxNumNodesPerFace extends to the coordinate bounds variables; this is an extension of the current convention.\n\n\n\n\nExample:\n\n\ndimensions:\nnMesh2_node = 5 ; // nNodes\nnMesh2_edge = 6 ; // nEdges\nnMesh2_face = 2 ; // nFaces\nnMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace\n\nTwo = 2 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\nMesh2:cf_role = \nmesh_topology\n ;\nMesh2:long_name = \nTopology data of 2D unstructured mesh\n ;\nMesh2:topology_dimension = 2 ;\nMesh2:node_coordinates = \nMesh2_node_x Mesh2_node_y\n ;\nMesh2:face_node_connectivity = \nMesh2_face_nodes\n ;\nMesh2:edge_node_connectivity = \nMesh2_edge_nodes\n ; // attribute required if variables will be defined on edges\nMesh2:edge_coordinates = \nMesh2_edge_x Mesh2_edge_y\n ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_coordinates = \nMesh2_face_x Mesh2_face_y\n ; // optional attribute\nMesh2:face_edge_connectivity = \nMesh2_face_edges\n ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_face_connectivity = \nMesh2_face_links\n ; // optional attribute\ninteger Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_nodes:cf_role = \nface_node_connectivity\n ;\nMesh2_face_nodes:long_name = \nMaps every face to its corner nodes.\n ;\nMesh2_face_nodes:_FillValue = 999999 ;\nMesh2_face_nodes:start_index = 1 ;\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\nMesh2_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh2_edge_nodes:long_name = \nMaps every edge to the two nodes that it connects.\n ;\nMesh2_edge_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_edges:cf_role = \nface_edge_connectivity\n ;\nMesh2_face_edges:long_name = \nMaps every face to its edges.\n ;\nMesh2_face_edges:_FillValue = 999999 ;\nMesh2_face_edges:start_index = 1 ;\ninteger Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_links:cf_role = \nface_face_connectivity\n ;\nMesh2_face_links:long_name = \nIndicates which other faces neighbor each face.\n ;\nMesh2_face_links:_FillValue = 999999 ;\nMesh2_face_links:start_index = 1 ;\nMesh2_face_links:flag_values = -1 ;\nMesh2_face_links:flag_meanings = \nout_of_mesh\n ;\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name = \nlongitude\n ;\nMesh2_node_x:long_name = \nLongitude of 2D mesh nodes.\n ;\nMesh2_node_x:units = \ndegrees_east\n ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name = \nlatitude\n ;\nMesh2_node_y:long_name = \nLatitude of 2D mesh nodes.\n ;\nMesh2_node_y:units = \ndegrees_north\n ;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name = \nlongitude\n ;\nMesh2_face_x:long_name = \nCharacteristics longitude of 2D mesh face.\n ;\nMesh2_face_x:units = \ndegrees_east\n ;\nMesh2_face_x:bounds = \nMesh2_face_xbnds\n ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name = \nlatitude\n ;\nMesh2_face_y:long_name = \nCharacteristics latitude of 2D mesh face.\n ;\nMesh2_face_y:units = \ndegrees_north\n ;\nMesh2_face_y:bounds = \nMesh2_face_ybnds\n ;\ndouble Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_xbnds:standard_name = \nlongitude\n ;\nMesh2_face_xbnds:long_name = \nLongitude bounds of 2D mesh face (i.e. corner coordinates).\n ;\nMesh2_face_xbnds:units = \ndegrees_east\n ;\nMesh2_face_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_ybnds:standard_name = \nlatitude\n ;\nMesh2_face_ybnds:long_name = \nLatitude bounds of 2D mesh face (i.e. corner coordinates).\n ;\nMesh2_face_ybnds:units = \ndegrees_north\n ;\nMesh2_face_ybnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_edge_x(nMesh2_edge) ;\nMesh2_edge_x:standard_name = \nlongitude\n ;\nMesh2_edge_x:long_name = \nCharacteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh2_edge_x:units = \ndegrees_east\n ;\ndouble Mesh2_edge_y(nMesh2_edge) ;\nMesh2_edge_y:standard_name = \nlatitude\n ;\nMesh2_edge_y:long_name = \nCharacteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh2_edge_y:units = \ndegrees_north\n ;\n// bounds variables for edges skipped\n\n\n\n\n3D layered mesh topology\n\uf0c1\n\n\nFor a 3D layered unstructured mesh topology this proposal follows the approach of the existing CF-conventions for structured meshes: horizontal and vertical dimensions are treated separately. For the horizontal plane a 2D unstructured mesh topology is defined, which is extruded in the vertical direction by means of a \nvertical coordinate\n. The example below matches the example in the previous section combined with a vertical coordinate according CF-conventions. This example introduces also the attributes \nmesh\n and \nlocation\n on the 2D variables \nMesh2_surface\n and \nMesh2_depth\n. For more information about these attributes see the \ndata definition\n section below.\n\n\n\n\nExample:\n\n\ndimensions:\nnMesh2_node = 6 ; // nNodes\nnMesh2_edge = 7 ; // nEdges\nnMesh2_face = 2 ; // nFaces\nnMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace\nMesh2_layers = 10 ;\n\nTwo = 2 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\nMesh2:cf_role = \nmesh_topology\n ;\nMesh2:long_name = \nTopology data of 2D unstructured mesh\n ;\nMesh2:topology_dimension = 2 ;\nMesh2:node_coordinates = \nMesh2_node_x Mesh2_node_y\n ;\nMesh2:face_node_connectivity = \nMesh2_face_nodes\n ;\nMesh2:edge_node_connectivity = \nMesh2_edge_nodes\n ; // attribute required if variables will be defined on edges\nMesh2:edge_coordinates = \nMesh2_edge_x Mesh2_edge_y\n ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_coordinates = \nMesh2_face_x Mesh2_face_y\n ; // optional attribute\nMesh2:face_edge_connectivity = \nMesh2_face_edges\n ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_face_connectivity = \nMesh2_face_links\n ; // optional attribute\ninteger Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_nodes:cf_role = \nface_node_connectivity\n ;\nMesh2_face_nodes:long_name = \nMaps every face to its corner nodes.\n ;\nMesh2_face_nodes:_FillValue = 999999 ;\nMesh2_face_nodes:start_index = 1 ;\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\nMesh2_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh2_edge_nodes:long_name = \nMaps every edge to the two nodes that it connects.\n ;\nMesh2_edge_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_edges:cf_role = \nface_edge_connectivity\n ;\nMesh2_face_edges:long_name = \nMaps every face to its edges.\n ;\nMesh2_face_edges:_FillValue = 999999 ;\nMesh2_face_edges:start_index = 1 ;\ninteger Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_links:cf_role = \nface_face_connectivity\n ;\nMesh2_face_links:long_name = \nIndicates which other faces neighbor each face.\n ;\nMesh2_face_links:_FillValue = 999999 ;\nMesh2_face_links:start_index = 1 ;\nMesh2_face_links:flag_values = -1 ;\nMesh2_face_links:flag_meanings = \nout_of_mesh\n ;\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name = \nlongitude\n ;\nMesh2_node_x:long_name = \nLongitude of 2D mesh nodes.\n ;\nMesh2_node_x:units = \ndegrees_east\n ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name = \nlatitude\n ;\nMesh2_node_y:long_name = \nLatitude of 2D mesh nodes.\n ;\nMesh2_node_y:units = \ndegrees_north\n ;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name = \nlongitude\n ;\nMesh2_face_x:long_name = \nCharacteristics longitude of 2D mesh face.\n ;\nMesh2_face_x:units = \ndegrees_east\n ;\nMesh2_face_x:bounds = \nMesh2_face_xbnds\n ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name = \nlatitude\n ;\nMesh2_face_y:long_name = \nCharacteristics latitude of 2D mesh face.\n ;\nMesh2_face_y:units = \ndegrees_north\n ;\nMesh2_face_y:bounds = \nMesh2_face_ybnds\n ;\ndouble Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_xbnds:standard_name = \nlongitude\n ;\nMesh2_face_xbnds:long_name = \nLongitude bounds of 2D mesh face (i.e. corner coordinates).\n ;\nMesh2_face_xbnds:units = \ndegrees_east\n ;\nMesh2_face_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_ybnds:standard_name = \nlatitude\n ;\nMesh2_face_ybnds:long_name = \nLatitude bounds of 2D mesh face (i.e. corner coordinates).\n ;\nMesh2_face_ybnds:units = \ndegrees_north\n ;\nMesh2_face_ybnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_edge_x(nMesh2_edge) ;\nMesh2_edge_x:standard_name = \nlongitude\n ;\nMesh2_edge_x:long_name = \nCharacteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh2_edge_x:units = \ndegrees_east\n ;\ndouble Mesh2_edge_y(nMesh2_edge) ;\nMesh2_edge_y:standard_name = \nlatitude\n ;\nMesh2_edge_y:long_name = \nCharacteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh2_edge_y:units = \ndegrees_north\n ;\n// bounds variables for edges skipped\n\n// Vertical coordinate\ndouble Mesh2_layers(Mesh2_layers) ;\nMesh2_layers:standard_name = \nocean_sigma_coordinate\n ;\nMesh2_layers:long_name = \nsigma at layer midpoints\n ;\nMesh2_layers:positive = \nup\n ;\nMesh2_layers:formula_terms = \nsigma: Mesh2_layers eta: Mesh2_surface depth: Mesh2_depth\n ;\ndouble Mesh2_depth(nMesh2_node) ;\nMesh2_depth:standard_name = \nsea_floor_depth_below_geoid\n ;\nMesh2_depth:units = \nm\n ;\nMesh2_depth:positive = \ndown\n ;\nMesh2_depth:mesh = \nMesh2\n\nMesh2_depth:location = \nnode\n ;\nMesh2_depth:coordinates = \nMesh2_node_x Mesh2_node_y\n ;\ndouble Mesh2_surface(nMesh2_node) ;\nMesh2_surface:standard_name = \nsea_surface_height_above_geoid\n ;\nMesh2_surface:units = \nm\n ;\nMesh2_surface:mesh = \nMesh2\n\nMesh2_surface:location = \nface\n ;\nMesh2_surface:coordinates = \nMesh2_face_x Mesh2_face_y\n ;\n\n\n\n\nFully 3D unstructured (i.e. non-layered) mesh topology\n\uf0c1\n\n\nFor a fully 3D unstructured mesh topology we extend the hierarchy of nodes, edges and faces to volumes. Contrary to layered case this type of mesh requires a fully 3D specification of the mesh; hence we not only need latitude and longitude coordinates but also some kind of elevation coordinate (\nthis probably requires a new standard name\n).\n\n\nThe topology information is stored as attributes to a dummy variable (in the example below called \nMesh3D\n) with \ncf_role\n mesh_topology.\n\n\n\n\n\n\n\n\nRequired topology attributes\n\n\nValue\n\n\n\n\n\n\n\n\n\n\ncf_role\n\n\nmesh_topology\n\n\n\n\n\n\ntopology_dimension\n\n\n3\n\n\n\n\n\n\nnode_coordinates\n\n\n\n\n\n\n\n\nvolume_node_connectivity\n\n\n\n\n\n\n\n\nvolume_shape_type\n\n\n\n\n\n\n\n\nOptionally-required attributes\n*\n\n\n\n\n\n\n\n\nface_node_connectivity\n\n\n\n\n\n\n\n\nedge_node_connectivity\n\n\n\n\n\n\n\n\nOptional attributes\n\n\n\n\n\n\n\n\nvolume_edge_connectivity\n\n\n\n\n\n\n\n\nvolume_face_connectivity\n\n\n\n\n\n\n\n\nvolume_volume_connectivity\n\n\n\n\n\n\n\n\nface_edge_connectivity\n\n\n\n\n\n\n\n\nboundary_node_connectivity\n\n\n\n\n\n\n\n\nvolume_coordinates\n\n\n\n\n\n\n\n\nface_coordinates\n\n\n\n\n\n\n\n\nedge_coordinates\n\n\n\n\n\n\n\n\n\n\n*The \nOptionally required\n attributes \nedge_node_connectivity\n and \nface_node_connectivity\n are required only if you want to store data on the edges or faces respectively (i.e. if you mind the numbering order of the edges/faces).\n\n\nThe attribute \ntopology_dimension\n indicates the highest dimensionality of the geometric elements; for a fully 3-dimensional unstructured mesh this should be 3. The attribute \nnode_coordinates\n points to the auxiliary coordinate variables representing the node locations (latitude, longitude, elevation and optional other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute \nvolume_node_connectivity\n points to an index variable identifying for every volume the indices of its corner nodes. For faces in the horizontal plane, it was possible to prescribe the order of the nodes, but this is not possible for the nodes of generic 3D volumes. For this reason we introduce an additional attribute \nvolume_shape_type\n which points to a flag variable that specifies for every volume its shape:\n\n\n\n\n\n\n\n\nflag_meaning name\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\ntetrahedron\n\n\npyramid with triangular base, 4 nodes\n\n\n\n\n\n\npyramid\n\n\npyramid with square base, a pentahedron, 5 nodes\n\n\n\n\n\n\nwedge\n\n\nprism with triangular base, a pentahedron, 6 nodes\n\n\n\n\n\n\nhexahedron\n\n\ndistorted cube, 8 nodes\n\n\n\n\n\n\n\n\nThese four volume shapes are the ones most commonly used. More shapes can be added; and if necessary, it\ns possible to add a generic shape type which allows for specification of the volume shape indirectly via \nvolume_face_connectivity\n and \nface_node_connectivity\n variables. Such a generic shape is not included in this proposal since there is no practical need for such feature at this time.\n\n\nIf all volumes have the same shape type, then the shape typed could be determined based on the number of nodes per volume. Another option could be to allow the \nvolume_shape_type\n to specify the shape type directly rather than pointing to a variable. However, for the time being we assume that the currently proposed volume shape type variable doesn\nt have too much impact on the performance.\n\n\nThe order in which the corner nodes of a volume are specified is fixed given its shape; this approach is common in 3D modeling, see e.g. \nthis graph in the OpenFOAM documentation\n and \nParaView\n or \nVTK\n documentation. The \nvolume_node_connectivity\n array will be a matrix of size nVolumes x MaxNumNodesPerVolume; if a volume has less corner nodes than MaxNumNodesPerVolume then the last node indices shall be equal to \n_FillValue\n (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a \nstart_index\n attribute to the index variable (i.e. Mesh3D_vol_nodes in the example below). Consistent with the CF-conventions \ncompression\n option, the connectivity indices are 0-based by default. See \nthis section on zero or one-based indexing\n for more details.\n\n\nIn case you want to define variables on the faces or edges of the 3D mesh topology you need to specify the \nface_node_connectivity\n or \nedge_node_connectivity\n attribute, respectively, to map faces or edges to nodes. Although the volume to node mapping implicitly also defines the location of the faces and edges, it does not specify their global numbering. Again the indexing convention of \nface_node_connectivity\n and \nedge_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable and 0-based indexing is the default. Since it does not apply to either nodes or edges globally, specifying the \nboundary_node_connectivity\n attribute described below does not (in and of itself) necessitate the need to specify \nedge_node_connectivity\n nor \nface_node_connectivity\n.\n\n\nOptionally the topology may have the following attributes:\n\n \nvolume_face_connectivity\n pointing to an index variable identifying for every volume the indices of its faces. The order in which the face indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumFacesPerVolume. If a volume has less faces than MaxNumFacesPerVolume then the last face indices shall be equal to \n_FillValue\n, and the indexing convention of \nvolume_edge_connectivity\n should be specified using the \nstart_index\n attribute to the index variable and 0-based indexing is the default.\n\n \nvolume_edge_connectivity\n pointing to an index variable identifying for every volume the indices of its edges. The order in which the edge indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumEdgesPerVolume. Again, if a volume has less edges than MaxNumEdgesPerVolume then the last edge indices shall be equal to \n_FillValue\n, and the indexing convention of \nvolume_edge_connectivity\n should be specified using the \nstart_index\n attribute to the index variable and 0-based indexing is the default.\n\n \nvolume_volume_connectivity\n pointing to an index variable identifying all volumes that share a face with each volume, i.e. are neighbors. This connectivity array will thus be a matrix of size nVolumes x MaxNumFacesPerVolume with a flag to note if the region \nout of mesh\n abuts a face of a given volume. Again, if a volume has less sides/faces than MaxNumFacesPerVolume then the last volume (column) indices shall be equal to \n_FillValue\n, and the indexing convention of \nvolume_volume_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh3D_vol_links in the example below) and 0-based indexing is the default.\n\n \nface_edge_connectivity\n pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. As always, if a face has less corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to \n_FillValue\n, and the indexing convention of \nface_edge_connectivity\n should be specified using the \nstart_index\n attribute to the index variable and 0-based indexing is the default.\n\n \nface_node_connectivity\n pointing to an index variable identifying for every face the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to \n_FillValue\n, and the indexing convention of \nface_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable and 0-based indexing is the default.\n\n \nboundary_node_connectivity\n pointing to an index variable identifying for every face of each boundary the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nBoundaryFaces x MaxNumNodesPerFace. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to \n_FillValue\n, and the indexing convention of \nboundary_node_connectivity\n should be specified using the \nstart_index\n attribute to the index variable (i.e. Mesh3D_boundary_nodes) and 0-based indexing is the default. Although constructed of faces, boundaries represent a different quantity than general face data and thus the \nboundary_node_connectivity\n attribute may be specified independent of \nface_node_connectivity\n.  Information about the nature of each boundary face (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryFaces X 1.\n* \nvolume_coordinates\n, \nface_coordinates\n and/or \nedge_coordinates\n pointing to the auxiliary coordinate variables associated with the characteristic location of the volumes, faces and edges. These auxiliary coordinate variables will have length nVolumes, nFaces and nEdges respectively, and may have in turn a \nbounds\n attribute that specifies the corner coordinates of the volume, face or edge (thereby duplicating the data in the \nnode_coordinates\n variables). The order in which the corner coordinates of the volumes is given by the volume geometry type.\n\n\n\n\nExample:\n\n\ndimensions:\nnMesh3D_node = 12 ; // nNodes\nnMesh3D_edge = 23 ; // nEdges\nnMesh3D_face = 16 ; // nFaces\nnMesh3D_vol = 4 ; // nVolumes\nnMaxMesh3D_face_nodes = 4 ; // MaxNumNodesPerFace\nnMaxMesh3D_vol_nodes = 8 ; // MaxNumNodesPerVolume\nnMaxMesh3D_vol_edges = 12 ; // MaxNumEdgesPerVolume\nnMaxMesh3D_vol_faces = 6 ; // MaxNumFacesPerVolume\n\nTwo = 2 ;\n\nvariables:\n// Mesh topology\ninteger Mesh3D ;\nMesh3D:cf_role = \nmesh_topology\n ;\nMesh3D:long_name = \nTopology data of 3D unstructured mesh\n ;\nMesh3D:topology_dimension = 3 ;\nMesh3D:node_coordinates = \nMesh3D_node_x Mesh3D_node_y Mesh3D_node_z\n ;\nMesh3D:volume_shape_type = \nMesh3D_vol_types\n ;\nMesh3D:volume_node_connectivity = \nMesh3D_vol_nodes\n ;\nMesh3D:face_node_connectivity = \nMesh3D_face_nodes\n ; // attribute required if variables will be defined on faces\nMesh3D:edge_node_connectivity = \nMesh3D_edge_nodes\n ; // attribute required if variables will be defined on edges\nMesh3D:edge_coordinates = \nMesh3D_edge_x Mesh3D_edge_y Mesh3D_edge_z\n ; // optional attribute (requires edge_node_connectivity)\nMesh3D:face_coordinates = \nMesh3D_face_x Mesh3D_face_y Mesh3D_face_z\n ; // optional attribute (requires face_node_connectivity)\nMesh3D:volume_coordinates = \nMesh3D_vol_x Mesh3D_vol_y Mesh3D_vol_z\n ; // optional attribute\nMesh3D:volume_face_connectivity = \nMesh3D_vol_faces\n ; // optional attribute (requires face_node_connectivity)\nMesh3D:volume_edge_connectivity = \nMesh3D_vol_edges\n ; // optional attribute (requires edge_node_connectivity)\nMesh3D:face_edge_connectivity = \nMesh3D_face_edges\n ; // optional attribute (requires face_node_connectivity and edge_node_connectivity)\nMesh3D:volume_volume_connectivity = \nMesh3D_vol_links\n ; // optional attribute\ninteger Mesh3D_vol_types(nMesh3D_vol) ;\nMesh3D_vol_types:cf_role = \nvolume_shape_type\n ;\nMesh3D_vol_types:long_name = \nSpecifies the shape of the individual volumes.\n ;\nMesh3D_vol_types:flag_range = 0b, 2b ;\nMesh3D_vol_types:flag_values = 0b, 1b, 2b ;\nMesh3D_vol_types:flag_meanings = \ntetrahedron wedge hexahedron\n ;\ninteger Mesh3D_vol_nodes(nMesh3D_vol, nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_nodes:cf_role = \nvolume_node_connectivity\n ;\nMesh3D_vol_nodes:long_name = \nMaps every volume to its corner nodes.\n ;\nMesh3D_vol_nodes:_FillValue = 999999 ;\nMesh3D_vol_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh3D_edge_nodes(nMesh3D_edge, Two) ;\nMesh3D_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh3D_edge_nodes:long_name = \nMaps every edge to the two nodes that it connects.\n ;\nMesh3D_edge_nodes:start_index = 1 ;\ninteger Mesh3D_face_nodes(nMesh3D_face, nMaxMesh3D_face_nodes) ;\nMesh3D_face_nodes:cf_role = \nface_node_connectivity\n ;\nMesh3D_face_nodes:long_name = \nMaps every face to its corner nodes.\n ;\nMesh3D_face_nodes:_FillValue = 999999 ;\nMesh3D_face_nodes:start_index = 1 ;\ninteger Mesh3D_vol_faces(nMesh3D_vol, nMaxMesh3D_vol_faces) ;\nMesh3D_vol_faces:cf_role = \nvolume_face_connectivity\n ;\nMesh3D_vol_faces:long_name = \nMaps every volume to its faces.\n ;\nMesh3D_vol_faces:_FillValue = 999999 ;\nMesh3D_vol_faces:start_index = 1 ;\ninteger Mesh3D_vol_edges(nMesh3D_vol, nMaxMesh3D_vol_edges) ;\nMesh3D_vol_edges:cf_role = \nvolume_edge_connectivity\n ;\nMesh3D_vol_edges:long_name = \nMaps every volume to its edges.\n ;\nMesh3D_vol_edges:_FillValue = 999999 ;\nMesh3D_vol_edges:start_index = 1 ;\ninteger Mesh3D_face_edges(nMesh3D_face, nMaxMesh3D_face_nodes) ;\nMesh3D_face_edges:cf_role = \nface_edge_connectivity\n ;\nMesh3D_face_edges:long_name = \nMaps every face to its edges.\n ;\nMesh3D_face_edges:_FillValue = 999999 ;\nMesh3D_face_edges:start_index = 1 ;\ninteger Mesh3D_vol_links(nMesh3D_vol, nMaxMesh3D_vol_faces) ;\nMesh3D_vol_links:cf_role = \nvolume_volume_connectivity\n ;\nMesh3D_vol_links:long_name = \nIndicates which other volumes neighbor each volume.\n ;\nMesh3D_vol_links:_FillValue = 999999 ;\nMesh3D_vol_links:start_index = 1 ;\nMesh3D_vol_links:flag_values = -1 ;\nMesh3D_vol_links:flag_meanings = \nout_of_mesh\n ;\n\n// Mesh node coordinates\ndouble Mesh3D_node_x(nMesh3D_node) ;\nMesh3D_node_x:standard_name = \nlongitude\n ;\nMesh3D_node_x:long_name = \nLongitude of 3D mesh nodes.\n ;\nMesh3D_node_x:units = \ndegrees_east\n ;\ndouble Mesh3D_node_y(nMesh3D_node) ;\nMesh3D_node_y:standard_name = \nlatitude\n ;\nMesh3D_node_y:long_name = \nLatitude of 3D mesh nodes.\n ;\nMesh3D_node_y:units = \ndegrees_north\n ;\ndouble Mesh3D_node_z(nMesh3D_node) ;\nMesh3D_node_z:standard_name = \nelevation\n ;\nMesh3D_node_z:long_name = \nElevation of 3D mesh nodes.\n ;\nMesh3D_node_z:units = \nm\n ;\n\n// Optional mesh volume, face and edge coordinate variables\ndouble Mesh3D_vol_x(nMesh3D_vol) ;\nMesh3D_vol_x:standard_name = \nlongitude\n ;\nMesh3D_vol_x:long_name = \nCharacteristics longitude of mesh volumes.\n ;\nMesh3D_vol_x:units = \ndegrees_east\n ;\nMesh3D_vol_x:bounds = \nMesh3D_vol_xbnds\n ;\ndouble Mesh3D_vol_y(nMesh3D_vol) ;\nMesh3D_vol_y:standard_name = \nlatitude\n ;\nMesh3D_vol_y:long_name = \nCharacteristics latitude of mesh volumes.\n ;\nMesh3D_vol_y:units = \ndegrees_north\n ;\nMesh3D_vol_y:bounds = \nMesh3D_vol_ybnds\n ;\ndouble Mesh3D_vol_z(nMesh3D_vol) ;\nMesh3D_vol_z:standard_name = \nelevation\n ;\nMesh3D_vol_z:long_name = \nCharacteristics elevation of mesh volumes.\n ;\nMesh3D_vol_z:units = \nm\n ;\nMesh3D_vol_z:bounds = \nMesh3D_vol_zbnds\n ;\ndouble Mesh3D_vol_xbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_xbnds:standard_name = \nlongitude\n ;\nMesh3D_vol_xbnds:long_name = \nLongitude bounds of mesh volumes (i.e. corner coordinates).\n ;\nMesh3D_vol_xbnds:units = \ndegrees_east\n ;\nMesh3D_vol_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh3D_vol_ybnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_ybnds:standard_name = \nlatitude\n ;\nMesh3D_vol_ybnds:long_name = \nLatitude bounds of mesh volumes (i.e. corner coordinates).\n ;\nMesh3D_vol_ybnds:units = \ndegrees_north\n ;\nMesh3D_vol_ybnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh3D_vol_zbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_zbnds:standard_name = \nelevation\n ;\nMesh3D_vol_zbnds:long_name = \nElevation bounds of mesh volumes (i.e. corner coordinates).\n ;\nMesh3D_vol_zbnds:units = \nm\n ;\nMesh3D_vol_zbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh3D_face_x(nMesh3D_face) ;\nMesh3D_face_x:standard_name = \nlongitude\n ;\nMesh3D_face_x:long_name = \nCharacteristics longitude of mesh faces.\n ;\nMesh3D_face_x:units = \ndegrees_east\n ;\ndouble Mesh3D_face_y(nMesh3D_face) ;\nMesh3D_face_y:standard_name = \nlatitude\n ;\nMesh3D_face_y:long_name = \nCharacteristics latitude of mesh faces.\n ;\nMesh3D_face_y:units = \ndegrees_north\n ;\ndouble Mesh3D_face_z(nMesh3D_face) ;\nMesh3D_face_z:standard_name = \nelevation\n ;\nMesh3D_face_z:long_name = \nCharacteristics elevation of mesh faces.\n ;\nMesh3D_face_z:units = \nm\n ;\n// bounds variables for faces skipped\ndouble Mesh3D_edge_x(nMesh3D_edge) ;\nMesh3D_edge_x:standard_name = \nlongitude\n ;\nMesh3D_edge_x:long_name = \nCharacteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh3D_edge_x:units = \ndegrees_east\n ;\ndouble Mesh3D_edge_y(nMesh3D_edge) ;\nMesh3D_edge_y:standard_name = \nlatitude\n ;\nMesh3D_edge_y:long_name = \nCharacteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh3D_edge_y:units = \ndegrees_north\n ;\ndouble Mesh3D_edge_z(nMesh3D_edge) ;\nMesh3D_edge_z:standard_name = \nlatitude\n ;\nMesh3D_edge_z:long_name = \nCharacteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\n ;\nMesh3D_edge_z:units = \ndegrees_north\n ;\n// bounds variables for edges skipped\n\n\n\n\nData defined on unstructured meshes\n\uf0c1\n\n\nAccording to CF-conventions a variable defined on a \nstructured\n mesh is specified as\n\n\ndouble waterlevel(time,nmax,mmax) ;\nwaterlevel:standard_name = \nsea_surface_height_above_geoid\n ;\nwaterlevel:units = \nm\n ;\nwaterlevel:coordinates = \nlat lon\n ;\n\n\n\n\nThe \ncoordinates\n attribute refers to the variables that contain the latitude and longitude coordinates. For a curvilinear grid these variables will share two spatial dimensions, here \nnmax\n and \nmmax\n: lat(nmax,mmax) and lon(nmax,mmax). In numerical models the various quantities are often computed at different locations of the mesh: staggered data. The standard CF-conventions don\nt offer specific support for this functionality and thus for every stagger location coordinates need to be provided separately: cell center coordinates, corner point coordinates, u-flux point coordinates, and v-flux point coordinates. The underlying topology of the mesh, i.e. how these coordinates (variable definition locations) relate to each other isn\nt stored in the file. This shortcoming is to some degree solved by the \ngridspec\n proposal by \nVenkatramani Balaji\n and Zhi Liang. We introduce here attributes that link to the topological data defined above.\n\n\nData variables\n\uf0c1\n\n\nThe use of the \ncoordinates\n attribute is copied from the CF-conventions. It is used to map the values of variables defined on the unstructured meshes directly to their location: latitude, longitude and optional elevation. To map the variable onto the topology of the underlying mesh, two new attributes have been introduced. First, the attribute \nmesh\n points to the mesh_topology variable containing the meta-data attributes of the mesh on which the variable has been defined. Second, the attribute \nlocation\n points to the (stagger) location within the mesh at which the variable is defined. Note that in this example the \ncoordinates\n attribute is redundant since the coordinates could also be obtained by using the \nface_coordinates\n attribute of the \nMesh2\n variable.\n\n\ndouble Mesh2_waterlevel(time,nMesh2_face) ;\nMesh2_waterlevel:standard_name = \nsea_surface_height_above_geoid\n ;\nMesh2_waterlevel:units = \nm\n ;\nMesh2_waterlevel:mesh = \nMesh2\n\nMesh2_waterlevel:location = \nface\n ;\nMesh2_waterlevel:coordinates = \nMesh2_face_x Mesh2_face_y\n ;\n\n\n\n\nVolume and flux variables\n\uf0c1\n\n\nThe same mesh geometry can be used in different ways to schematize the hydrodynamic volumes and fluxes. Let\ns take a simple triangular mesh. From a finite volume point of view this mesh will generally be interpreted as consisting of two volumes with triangular base. However, others may use a continuous Galerkin finite element method that can be shown to be equivalent to a subdivision into four volumes. In the former case the two faces correspond to volumes and the fluxes \ncross\n the edges. In the latter case the volumes are defined surrounding the four nodes and the fluxes are directed \nalong\n the edges. The two abbreviated \nncdumps\n below show how the basic 2D triangular mesh definition can be extended to include this data. The coordinate variables for the volume data now include \nbounds\n attributes to define the surface area of the volumes. Note the subtle difference in the long names between the flux variables in the two cases; the \nstandard_name\n attribute has to make a more formal distinction between the two cases.\n\n\n \n\n\nVariant 1: Volume at faces:\n\n\ndimensions:\nnMesh2_node = 4 ; // nNodes\nnMesh2_edge = 5 ; // nEdges\nnMesh2_face = 2 ; // nFaces\n\nTwo = 2 ;\nThree = 3 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_nodes(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\n// as in 2D triangular mesh example\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_links(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\n// as in 2D triangular mesh example\ndouble Mesh2_node_y(nMesh2_node) ;\n// as in 2D triangular mesh example\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name = \nlongitude\n ;\nMesh2_face_x:long_name = \nCharacteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).\n ;\nMesh2_face_x:units = \ndegrees_east\n ;\nMesh2_face_x:bounds = \nMesh2_face_xbnds\n ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name = \nlatitude\n ;\nMesh2_face_y:long_name = \nCharacteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).\n ;\nMesh2_face_y:units = \ndegrees_north\n ;\nMesh2_face_y:bounds = \nMesh2_face_ybnds\n ;\ndouble Mesh2_face_xbnds(nMesh2_face,Three) ;\nMesh2_face_xbnds:standard_name = \nlongitude\n ;\nMesh2_face_xbnds:long_name = \nLongitude bounds of 2D mesh triangle (i.e. corner coordinates).\n ;\nMesh2_face_xbnds:units = \ndegrees_east\n ;\ndouble Mesh2_face_ybnds(nMesh2_face,Three) ;\nMesh2_face_ybnds:standard_name = \nlatitude\n ;\nMesh2_face_ybnds:long_name = \nLatitude bounds of 2D mesh triangle (i.e. corner coordinates).\n ;\nMesh2_face_ybnds:units = \ndegrees_north\n ;\ndouble Mesh2_edge_x(nMesh2_edge) ;\n// as in 2D triangular mesh example\ndouble Mesh2_edge_y(nMesh2_edge) ;\n// as in 2D triangular mesh example\n\n// Volume and flux data\ndouble Mesh2_volumes(nMesh2_face) ;\nMesh2_volumes:long_name = \nvolumes\n ;\nMesh2_volumes:units = \nm3\n ;\nMesh2_volumes:mesh = \nMesh2\n ;\nMesh2_volumes:location = \nface\n ;\nMesh2_volumes:coordinates = \nMesh2_face_x Mesh2_face_y\n ;\ndouble Mesh2_fluxes(nMesh2_edge) ;\nMesh2_fluxes:long_name = \nflux across edge\n ;\nMesh2_fluxes:units = \nm3 s-1\n ;\nMesh2_fluxes:mesh = \nMesh2\n\nMesh2_fluxes:location = \nedge\n ;\nMesh2_fluxes:coordinates = \nMesh2_edge_x Mesh2_edge_y\n ;\n\n\n\n\nVariant 2: Volume at nodes:\n\n\ndimensions:\nnMesh2_node = 4 ; // nNodes\nnMesh2_edge = 5 ; // nEdges\nnMesh2_face = 2 ; // nFaces\nnMaxMesh2_bnds = 6 ;\n\nTwo = 2 ;\nThree = 3 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_nodes(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\n// as in 2D triangular mesh example\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_links(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name = \nlongitude\n ;\nMesh2_node_x:long_name = \nLongitude of 2D mesh nodes.\n ;\nMesh2_node_x:units = \ndegrees_east\n ;\nMesh2_node_x:bounds = \nMesh2_node_xbnds\n ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name = \nlatitude\n ;\nMesh2_node_y:long_name = \nLatitude of 2D mesh nodes.\n ;\nMesh2_node_y:units = \ndegrees_north\n ;\nMesh2_node_y:bounds = \nMesh2_node_ybnds\n ;\ndouble Mesh2_node_xbnds(nMesh2_node, nMaxMesh2_bnds) ;\nMesh2_node_xbnds:standard_name = \nlongitude\n ;\nMesh2_node_xbnds:long_name = \nList of x-points that form outline of flow volume\n ;\nMesh2_node_xbnds:units = \ndegrees_east\n ;\nMesh2_node_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_node_ybnds(nMesh2_node, nMaxMesh2_bnds) ;\nMesh2_node_ybnds:standard_name = \nlatitude\n ;\nMesh2_node_ybnds:units = \ndegrees_north\n ;\nMesh2_node_ybnds:long_name = \nList of y-points that form outline of flow volume\n ;\nMesh2_node_xbnds:_FillValue = 9.9692099683868690E36;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\n// as in 2D triangular mesh example\ndouble Mesh2_face_y(nMesh2_face) ;\n// as in 2D triangular mesh example\ndouble Mesh2_edge_x(nMesh2_edge) ;\n// as in 2D triangular mesh example\ndouble Mesh2_edge_y(nMesh2_edge) ;\n// as in 2D triangular mesh example\n\n// Volume and flux data\ndouble Mesh2_volumes(nMesh2_node) ;\nMesh2_volumes:long_name = \nvolumes\n ;\nMesh2_volumes:units = \nm3\n ;\nMesh2_volumes:mesh = \nMesh2\n ;\nMesh2_volumes:location = \nnode\n ;\nMesh2_volumes:coordinates = \nMesh2_node_x Mesh2_node_y\n ;\ndouble Mesh2_fluxes(nMesh2_edge) ;\nMesh2_fluxes:long_name = \nflux along edge\n ;\nMesh2_fluxes:units = \nm3 s-1\n ;\nMesh2_fluxes:mesh = \nMesh2\n\nMesh2_fluxes:location = \nedge\n ;\nMesh2_fluxes:coordinates = \nMesh2_edge_x Mesh2_edge_y\n ;\n\n\n\n\nLocation index set\n\uf0c1\n\n\nSome variables may only be defined at specific locations within the mesh, e.g. only at boundary points or at special locations like weirs and gates. To save space and to improve readability, the concept of a location_index_set is introduced. It is basically identical to the \ncompression\n option in the the CF-conventions except for the fact that the compression works on a (set of) orthogonal coordinate dimension(s) and the location_index_set works on a topology location.\n\n\nThe location index set is an integer variable that contains the indices of the locations at which a specific quantity is defined. The example below defines a location index set \nMesh1_set\n as a subset of the \nnode\ns of Mesh1 (red points). The attribute \nlocation_index_set\n of the variable \nMesh_waterlevel\n points to this index set and the \ncoordinates\n attribute points to the corresponding (subset) of latitude and longitude coordinates. The \nmesh\n and \nlocation\n attributes of the location_index_set variable are required; the \ncoordinates\n attribute is optional. Note that the \ncoordinates\n attributes on both \nMesh1_cell\n and \nMesh1_waterlevel\n are again redundant since the coordinates could also be obtained by using the index set \nMesh1_set\n and the \nnode_coordinates\n attribute of the \nMesh1\n variable. Consistent with all other index variables defined here, the indexing convention of the location index set should be specified using the \nstart_index\n attribute to the index variable and 0-based indexing is the default. See \nthis section on zero or one-based indexing\n for more details.\n\n\nContrary to a coordinate variable, the index set doesn\nt have to be monotonic. So, it can be used for creating subsets of the original locations as well as for renumbering the locations. If the \nlocation_index_set\n attribute is used on a variable, then the \nmesh\n and \nlocation\n attributes should not also be used on that variable.\n\n\n\n\ndimensions:\nnMesh1_set = 4 ;\n\nvariables:\ninteger Mesh1_set(nMesh1_set) ;\nMesh1_set:cf_role = \nlocation_index_set\n ;\nMesh1_set:long_name = \nDefines Mesh1_set as subset of the nodes of Mesh1.\n ;\nMesh1_set:mesh = \nMesh1\n ;\nMesh1_set:location = \nnode\n ;\nMesh1_set:start_index = 1 ;\nMesh1_set:coordinates = \nMesh1_set_x Mesh1_set_y\n ;\ndouble Mesh1_set_x(nMesh1_set) ;\nMesh1_set_x:standard_name = \nlongitude\n ;\nMesh1_set_x:long_name = \nCharacteristic longitude of set (e.g. longitude of node).\n ;\nMesh1_set_x:units = \ndegrees_east\n ;\ndouble Mesh1_set_y(nMesh1_set) ;\nMesh1_set_y:standard_name = \nlatitude\n ;\nMesh1_set_y:long_name = \nCharacteristic latitude of set (e.g. latitude of node)\n ;\nMesh1_set_y:units = \ndegrees_north\n ;\n\ndouble Mesh1_waterlevel(time, nMesh1_set) ;\nMesh1_waterlevel:standard_name = \nsea_surface_height_above_geoid\n ;\nMesh1_waterlevel:units = \nm\n ;\nMesh1_waterlevel:location_index_set = \nMesh1_set\n ;\nMesh1_waterlevel:coordinates = \nMesh1_set_x Mesh1_set_y\n ;\n\n\n\n\n\n\nZero or One-based indexing\n\uf0c1\n\n\nThe indexing using by the CF \ncompression\n option is 0-based. Therefore, it is most consistent for this CF extension for unstructured data to also use 0-based indexing, which means that points, edges, faces and volumes will be numbered starting with 0. This convention is consistent with languages like C and Java, but unlike Fortran and MATLAB. Since many of the unstructured models have been programmed in Fortran and legacy NetCDF files exist that use 1-based indexing (which could be upgraded to be consistent with this new proposal using ncML if 1-based indexing were allowed), we propose to support both 0- and 1-based indexing by means of the \nstart_index\n attribute. You will find below two examples of the same network geometry using either 0- or 1-based indexing. Switching between 0- and 1-based indexing is as easy as adding 1 to or subtracting 1 from the indices upon reading or writing depending on the setting of \nstart_index\n; allowing both options should only have a minor impact on the reading routines and no effect at all on the rest of your code.\n\n\nExample of 0-based indexing:\n\n\n\n\ndimensions:\nnMesh1_node = 5 ; // nNodes\nnMesh1_edge = 4 ; // nEdges\n\nTwo = 2;\n\nvariables:\n// Mesh topology\ninteger Mesh1 ;\nMesh1:cf_role = \nmesh_topology\n ;\nMesh1:long_name = \nTopology data of 1D network\n ;\nMesh1:topology_dimension = 1 ;\nMesh1:node_coordinates = \nMesh1_node_x Mesh1_node_y\n ;\nMesh1:edge_node_connectivity = \nMesh1_edge_nodes\n ;\nMesh1:edge_coordinates = \nMesh1_edge_x Mesh1_edge_y\n ; // optional attribute\ninteger Mesh1_edge_nodes(nMesh1_edge, Two) ;\nMesh1_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh1_edge_nodes:long_name = \nMaps every edge/link to the two nodes that it connects.\n ;\nMesh1_edge_nodes:start_index = 0 ; // default setting, attribute could have been skipped.\n\n// Coordinate variables skipped\n\ndata:\n\nMesh1 = 0 ; // dummy\n\nMesh1_edge_nodes =\n0, 2,\n1, 2,\n2, 3,\n3, 4 ;\n\n\n\n\nExample of 1-based indexing:\n\n\n\n\ndimensions:\nnMesh1_node = 5 ; // nNodes\nnMesh1_edge = 4 ; // nEdges\n\nTwo = 2;\n\nvariables:\n// Mesh topology\ninteger Mesh1 ;\nMesh1:cf_role = \nmesh_topology\n ;\nMesh1:long_name = \nTopology data of 1D network\n ;\nMesh1:topology_dimension = 1 ;\nMesh1:node_coordinates = \nMesh1_node_x Mesh1_node_y\n ;\nMesh1:edge_node_connectivity = \nMesh1_edge_nodes\n ;\nMesh1:edge_coordinates = \nMesh1_edge_x Mesh1_edge_y\n ; // optional attribute\ninteger Mesh1_edge_nodes(nMesh1_edge, Two) ;\nMesh1_edge_nodes:cf_role = \nedge_node_connectivity\n ;\nMesh1_edge_nodes:long_name = \nMaps every edge/link to the two nodes that it connects.\n ;\nMesh1_edge_nodes:start_index = 1 ;\n\n// Coordinate variables skipped\n\ndata:\n\nMesh1 = 0 ; // dummy\n\nMesh1_edge_nodes =\n1, 3,\n2, 3,\n3, 4,\n4, 5 ;", 
            "title": "Home"
        }, 
        {
            "location": "/#ugrid-conventions", 
            "text": "", 
            "title": "UGRID Conventions"
        }, 
        {
            "location": "/#introduction", 
            "text": "This page describes a proposal for storing unstructured (or flexible mesh) model data in the Unidata Network Common Data Form (NetCDF) file. Our focus is on data for environmental applications and hence we start from the  Climate   Forecast (CF) Metadata Conventions . The CF Conventions have been the standard in climate research for many years, and are  being adopted by others as the metadata standard (e.g.  NASA , Open Geospatial Consortium ). The CF conventions allow you to provide the geospatial and temporal coordinates for scientific data, but currently assumes that the horizontal topology may be inferred from the i,j indices of structured grids.  This proposal adds conventions for specifying the topology for unstructured (e.g. triangular) grids.    In its most basic form unstructured data may be stored as data defined at a series of points, the CF-conventions are then sufficient. However, it is often useful or even necessary to also know the topology of the underlying unstructured mesh: is it a one dimensional (1D) network, a two dimensional (2D) triangular mesh or more flexible mixed triangle/quadrilateral mesh, a 2D mesh with vertical layers, or a fully unstructured three dimensional (3D) mesh. This document describes the attribute conventions for storing the mesh topology and for associating variables with (specific locations on) the mesh topology. The conventions have been designed to store the output data of a combined 1D-2D-3D flow model with staggered data, but the metadata for a simple 1D network or 2D triangular mesh doesn t suffer from the genericity needed for the most complex models.  Due to the complexity in unstructured mesh models, some concepts have not yet been worked out in this version.  Known issues left for future versions include:   adaptive mesh topology (this could be supported by defining a  time_concatenation  attribute for a time-series of mesh topologies)  higher order element data; for an idea how such data could be stored see this other  proposal .  subgrid data; the NetCDF pages by the Bundesanstalt f\u00fcr Wasserbau (BAW) contain some proposals on this topic ( see their pages (in German) ).  3D fully unstructured meshes (some concepts are included here, but still somewhat limited in scope).  multiply-connected domains  ghost elements", 
            "title": "Introduction"
        }, 
        {
            "location": "/#topology", 
            "text": "", 
            "title": "Topology"
        }, 
        {
            "location": "/#naming-conventions-for-geometrical-elements", 
            "text": "Inspired by Wikipedia s definition of  network topology , we define the mesh topology here as the interconnection of various geometrical elements of the mesh. The pure interconnectivity is independent of georeferencing the individual geometrical elements, but for the practical applications for which we are defining this CF extension, we ll always add coordinate data. Within a mesh, one can distinguish 0-, 1-, 2- and 3-dimensional elements. We need some names to identify these four types of elements; after discussion we propose the following names:     Dimensionality  Proposed Name  Comments      0  node  A point, a coordinate pair or triplet: the most basic element of the topology. The word  node  seems to be more commonly used than the alternative  vertex .    1  edge  A line or curve bounded by two nodes.    2  face  A plane or surface enclosed by a set of edges. In a 2D horizontal application one may consider the word  polygon , but in the hierarchy of elements the word  face  is most common.    3  volume  A volume enclosed by a set of faces.  The alternative word  cell  was considered, but  cell  is often used in the community to describe 2 dimensional structures.     In favor of simpler code for interpreting compliant files, we have dropped to use of the  locations  attribute which allowed the user to specify his/her own names for nodes, edges, faces and volumes.", 
            "title": "Naming conventions for geometrical elements"
        }, 
        {
            "location": "/#1d-network-topology", 
            "text": "The topology information is stored as attributes to a dummy variable (in the example below called  Mesh1 ) with  cf_role  mesh_topology.     Required topology attributes  Value      cf_role  mesh_topology    topology_dimension  1    node_coordinates     edge_node_connectivity     Optional attributes     edge_coordinates      The attribute  topology_dimension  indicates the highest dimensionality of the geometric elements; for a 1D network this should be 1. The attribute  node_coordinates  points to the auxiliary coordinate variables representing the node locations (latitude, longitude, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute  edge_node_connectivity  points to an index variable identifying for every edge to the indices of its begin and end nodes. The connectivity array will thus be a matrix of size nEdges x 2. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a  start_index  attribute to the index variable (i.e. Mesh1_edge_nodes in the example below). Consistent with the CF-conventions  compression  option, the connectivity indices are 0-based by default.  The option to support both 0- and 1-based indexing was introduced to be able to support existing files with 1-based index tables using ncML.  See  this section on zero or one-based indexing  for more details.   The mesh_topology may optionally include an  edge_coordinates  attribute which points to the auxiliary coordinate variables associated with the characteristic location of the edge (commonly the midpoint). These auxiliary coordinate variables will have length nEdges, and may have in turn a  bounds  attribute that specifies the bounding coordinates of the edge (thereby duplicating the data in the  node_coordinates  variables).  This use of the  bounds  attribute is consistent with the CF-convention on the use of  bounds  for multi-dimensional coordinate variables with p-sided cells, but it may not strictly be supported by the CF-convention right now.   Example:  dimensions:\nnMesh1_node = 5 ; // nNodes\nnMesh1_edge = 4 ; // nEdges\n\nTwo = 2;\n\nvariables:\n// Mesh topology\ninteger Mesh1 ;\nMesh1:cf_role =  mesh_topology  ;\nMesh1:long_name =  Topology data of 1D network  ;\nMesh1:topology_dimension = 1 ;\nMesh1:node_coordinates =  Mesh1_node_x Mesh1_node_y  ;\nMesh1:edge_node_connectivity =  Mesh1_edge_nodes  ;\nMesh1:edge_coordinates =  Mesh1_edge_x Mesh1_edge_y  ; // optional attribute\ninteger Mesh1_edge_nodes(nMesh1_edge, Two) ;\nMesh1_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh1_edge_nodes:long_name =  Maps every edge/link to the two nodes that it connects.  ;\nMesh1_edge_nodes:start_index = 1 ;\n\n// Mesh node coordinates\ndouble Mesh1_node_x(nMesh1_node) ;\nMesh1_node_x:standard_name =  longitude  ;\nMesh1_node_x:long_name =  Longitude of 1D network nodes.  ;\nMesh1_node_x:units =  degrees_east  ;\ndouble Mesh1_node_y(nMesh1_node) ;\nMesh1_node_y:standard_name =  latitude  ;\nMesh1_node_y:long_name =  Latitude of 1D network nodes.  ;\nMesh1_node_y:units =  degrees_north  ;\n\n// Optional mesh edge coordinate variables\ndouble Mesh1_edge_x(nMesh1_edge) ;\nMesh1_edge_x:standard_name =  longitude  ;\nMesh1_edge_x:long_name =  Characteristic longitude of 1D network edge (e.g. midpoint of the edge).  ;\nMesh1_edge_x:units =  degrees_east  ;\nMesh1_edge_x:bounds =  Mesh1_edge_xbnds  ;\ndouble Mesh1_edge_y(nMesh1_edge) ;\nMesh1_edge_y:standard_name =  latitude  ;\nMesh1_edge_y:long_name =  Characteristic latitude of 1D network edge (e.g. midpoint of the edge).  ;\nMesh1_edge_y:units =  degrees_north  ;\nMesh1_edge_y:bounds =  Mesh1_edge_ybnds  ;\ndouble Mesh1_edge_xbnds(nMesh1_edge,Two) ;\nMesh1_edge_xbnds:standard_name =  longitude  ;\nMesh1_edge_xbnds:long_name =  Longitude bounds of 1D network edge (i.e. begin and end longitude).  ;\nMesh1_edge_xbnds:units =  degrees_east  ;\ndouble Mesh1_edge_ybnds(nMesh1_edge,Two) ;\nMesh1_edge_ybnds:standard_name =  latitude  ;\nMesh1_edge_ybnds:long_name =  Latitude bounds of 1D network edge (i.e. begin and end latitude).  ;\nMesh1_edge_ybnds:units =  degrees_north  ;", 
            "title": "1D network topology"
        }, 
        {
            "location": "/#2d-triangular-mesh-topology", 
            "text": "The topology information is stored as attributes to a dummy variable (in the example below called  Mesh2 ) with  cf_role  mesh_topology.     Required topology attributes  Value      cf_role  mesh_topology    topology_dimension  2    node_coordinates     face_node_connectivity     Optionally required attributes *     edge_node_connectivity     Optional attributes      face_edge_connectivity     face_face_connectivity     boundary_node_connectivity     face_coordinates     edge_coordinates      *The  Optionally required  attribute  edge_node_connectivity  is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges).  The attribute  topology_dimension  indicates the highest dimensionality of the geometric elements; for a 2-dimensional (triangular) mesh this should be 2. The attribute  node_coordinates  points to the auxiliary coordinate variables representing the node locations (latitude, longitude, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute  face_node_connectivity  points to an index variable identifying for every face (here consistently triangle) the indices of its three corner nodes. The corner nodes should be specified in anticlockwise (also referred to as counterclockwise) direction as viewed from above (consistent with the CF-convention for  bounds  of p-sided cells. The connectivity array will thus be a matrix of size nFaces x 3. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a  start_index  attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions  compression  option, the connectivity indices are 0-based by default. See  this section on zero or one-based indexing  for more details.  In case you want to define variables on the edges of the triangular mesh topology you need to specify the  edge_node_connectivity  attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of  edge_node_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default.  Since it does not apply to edges globally, specifying the  boundary_node_connectivity  attribute described below does not (in and of itself) necessitate the need to specify the  edge_node_connectivity  attribute too.  Optionally the topology may have the following attributes:   face_edge_connectivity  pointing to an index variable identifying for every face (here consistently triangle) the indices of its three edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will thus be a matrix of size nFaces x 3. Again the indexing convention of  face_edge_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default.   face_face_connectivity  pointing to an index variable identifying all faces (here consistently triangle) that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x 3 with a flag to note if the region  out of mesh  abuts an edge of a given face. Again the indexing convention of  face_face_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_face_links in the example below) and 0-based indexing is the default.   boundary_node_connectivity  pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects.  Again the indexing convention of  boundary_node_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default.  Although constructed of edges, boundaries represent a different quantity than general edge data and thus the  boundary_node_connectivity  attribute may be specified independent of  edge_node_connectivity .  Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1.   face_coordinates  and/or  edge_coordinates  pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a  bounds  attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the  node_coordinates  variables).   Example:  dimensions:\nnMesh2_node = 4 ; // nNodes\nnMesh2_edge = 5 ; // nEdges\nnMesh2_face = 2 ; // nFaces\n\nTwo = 2 ;\nThree = 3 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\nMesh2:cf_role =  mesh_topology  ;\nMesh2:long_name =  Topology data of 2D unstructured mesh  ;\nMesh2:topology_dimension = 2 ;\nMesh2:node_coordinates =  Mesh2_node_x Mesh2_node_y  ;\nMesh2:face_node_connectivity =  Mesh2_face_nodes  ;\nMesh2:edge_node_connectivity =  Mesh2_edge_nodes  ; // attribute required if variables will be defined on edges\nMesh2:edge_coordinates =  Mesh2_edge_x Mesh2_edge_y  ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_coordinates =  Mesh2_face_x Mesh2_face_y  ; // optional attribute\nMesh2:face_edge_connectivity =  Mesh2_face_edges  ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_face_connectivity =  Mesh2_face_links  ; // optional attribute\ninteger Mesh2_face_nodes(nMesh2_face, Three) ;\nMesh2_face_nodes:cf_role =  face_node_connectivity  ;\nMesh2_face_nodes:long_name =  Maps every triangular face to its three corner nodes.  ;\nMesh2_face_nodes:start_index = 1 ;\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\nMesh2_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh2_edge_nodes:long_name =  Maps every edge to the two nodes that it connects.  ;\nMesh2_edge_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, Three) ;\nMesh2_face_edges:cf_role =  face_edge_connectivity  ;\nMesh2_face_edges:long_name =  Maps every triangular face to its three edges.  ;\nMesh2_face_edges:start_index = 1 ;\ninteger Mesh2_face_links(nMesh2_face, Three) ;\nMesh2_face_links:cf_role =  face_face_connectivity  ;\nMesh2_face_links:long_name =  Indicates which other faces neighbor each face.  ;\nMesh2_face_links:start_index = 1 ;\nMesh2_face_links:flag_values = -1 ;\nMesh2_face_links:flag_meanings =  out_of_mesh  ;\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name =  longitude  ;\nMesh2_node_x:long_name =  Longitude of 2D mesh nodes.  ;\nMesh2_node_x:units =  degrees_east  ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name =  latitude  ;\nMesh2_node_y:long_name =  Latitude of 2D mesh nodes.  ;\nMesh2_node_y:units =  degrees_north  ;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name =  longitude  ;\nMesh2_face_x:long_name =  Characteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).  ;\nMesh2_face_x:units =  degrees_east  ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name =  latitude  ;\nMesh2_face_y:long_name =  Characteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).  ;\nMesh2_face_y:units =  degrees_north  ;\ndouble Mesh2_edge_x(nMesh2_edge) ;\nMesh2_edge_x:standard_name =  longitude  ;\nMesh2_edge_x:long_name =  Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh2_edge_x:units =  degrees_east  ;\ndouble Mesh2_edge_y(nMesh2_edge) ;\nMesh2_edge_y:standard_name =  latitude  ;\nMesh2_edge_y:long_name =  Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh2_edge_y:units =  degrees_north  ;", 
            "title": "2D triangular mesh topology"
        }, 
        {
            "location": "/#2d-flexible-mesh-mixed-triangles-quadrilaterals-etc-topology", 
            "text": "The case of a 2D mesh with mixed face sizes is identical to the 2D triangular mesh discussed above with the exception that not all faces have the same number of nodes. To support this variability we may use in the future a ragged array, but here we propose to use _FillValue to indicate faces with smaller number of nodes than the arrays allow.  The topology information is stored as attributes to a dummy variable (in the example below called  Mesh2 ) with  cf_role  mesh_topology.     Required topology attributes  Value      cf_role  mesh_topology    topology_dimension  2    node_coordinates     face_node_connectivity     Optionally required attributes *     edge_node_connectivity     Optional attributes     face_edge_connectivity     face_face_connectivity     boundary_node_connectivity     face_coordinates     edge_coordinates      *The  Optionally required  attribute  edge_node_connectivity  is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges).  The attribute  topology_dimension  indicates the highest dimensionality of the geometric elements; for a 2-dimensional mesh this should be 2. The attribute  node_coordinates  points to the auxiliary coordinate variables representing the node locations (latitude, longitude, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute  face_node_connectivity  points to an index variable identifying for every face the indices of its corner nodes. The corner nodes should be specified in anticlockwise direction as viewed from above (consistent with the CF-convention for  bounds  of p-sided cells. The connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace; if a face has less corner nodes than MaxNumNodesPerFace then the last node indices shall be equal to  _FillValue  (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a  start_index  attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions  compression  option, the connectivity indices are 0-based by default. See  this section on zero or one-based indexing  for more details.  In case you want to define variables on the edges of the 2D mesh topology you need to specify the  edge_node_connectivity  attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of  edge_node_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default. Since it does not apply to edges globally, specifying the  boundary_node_connectivity  attribute described below does not (in and of itself) necessitate the need to specify the  edge_node_connectivity  attribute too.  Optionally the topology may have the following attributes:   face_edge_connectivity  pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to  _FillValue , and the indexing convention of  face_edge_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default.   face_face_connectivity  pointing to an index variable identifying all faces that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x MaxNumNodesPerFace with a flag to note if the region  out of mesh  abuts an edge of a given face. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last face (column) indices shall be equal to  _FillValue , and the indexing convention of  face_face_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_face_links in the example below) and 0-based indexing is the default.   boundary_node_connectivity  pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects.  Again the indexing convention of  boundary_node_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default.  Although constructed of edges, boundaries represent a different quantity than general edge data and thus the  boundary_node_connectivity  attribute may be specified independent of  edge_node_connectivity .  Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1.   face_coordinates  and/or  edge_coordinates  pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a  bounds  attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the  node_coordinates  variables).  The use of  _FillValue  to indicate faces with less nodes than MaxNumNodesPerFace extends to the coordinate bounds variables; this is an extension of the current convention.   Example:  dimensions:\nnMesh2_node = 5 ; // nNodes\nnMesh2_edge = 6 ; // nEdges\nnMesh2_face = 2 ; // nFaces\nnMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace\n\nTwo = 2 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\nMesh2:cf_role =  mesh_topology  ;\nMesh2:long_name =  Topology data of 2D unstructured mesh  ;\nMesh2:topology_dimension = 2 ;\nMesh2:node_coordinates =  Mesh2_node_x Mesh2_node_y  ;\nMesh2:face_node_connectivity =  Mesh2_face_nodes  ;\nMesh2:edge_node_connectivity =  Mesh2_edge_nodes  ; // attribute required if variables will be defined on edges\nMesh2:edge_coordinates =  Mesh2_edge_x Mesh2_edge_y  ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_coordinates =  Mesh2_face_x Mesh2_face_y  ; // optional attribute\nMesh2:face_edge_connectivity =  Mesh2_face_edges  ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_face_connectivity =  Mesh2_face_links  ; // optional attribute\ninteger Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_nodes:cf_role =  face_node_connectivity  ;\nMesh2_face_nodes:long_name =  Maps every face to its corner nodes.  ;\nMesh2_face_nodes:_FillValue = 999999 ;\nMesh2_face_nodes:start_index = 1 ;\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\nMesh2_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh2_edge_nodes:long_name =  Maps every edge to the two nodes that it connects.  ;\nMesh2_edge_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_edges:cf_role =  face_edge_connectivity  ;\nMesh2_face_edges:long_name =  Maps every face to its edges.  ;\nMesh2_face_edges:_FillValue = 999999 ;\nMesh2_face_edges:start_index = 1 ;\ninteger Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_links:cf_role =  face_face_connectivity  ;\nMesh2_face_links:long_name =  Indicates which other faces neighbor each face.  ;\nMesh2_face_links:_FillValue = 999999 ;\nMesh2_face_links:start_index = 1 ;\nMesh2_face_links:flag_values = -1 ;\nMesh2_face_links:flag_meanings =  out_of_mesh  ;\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name =  longitude  ;\nMesh2_node_x:long_name =  Longitude of 2D mesh nodes.  ;\nMesh2_node_x:units =  degrees_east  ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name =  latitude  ;\nMesh2_node_y:long_name =  Latitude of 2D mesh nodes.  ;\nMesh2_node_y:units =  degrees_north  ;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name =  longitude  ;\nMesh2_face_x:long_name =  Characteristics longitude of 2D mesh face.  ;\nMesh2_face_x:units =  degrees_east  ;\nMesh2_face_x:bounds =  Mesh2_face_xbnds  ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name =  latitude  ;\nMesh2_face_y:long_name =  Characteristics latitude of 2D mesh face.  ;\nMesh2_face_y:units =  degrees_north  ;\nMesh2_face_y:bounds =  Mesh2_face_ybnds  ;\ndouble Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_xbnds:standard_name =  longitude  ;\nMesh2_face_xbnds:long_name =  Longitude bounds of 2D mesh face (i.e. corner coordinates).  ;\nMesh2_face_xbnds:units =  degrees_east  ;\nMesh2_face_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_ybnds:standard_name =  latitude  ;\nMesh2_face_ybnds:long_name =  Latitude bounds of 2D mesh face (i.e. corner coordinates).  ;\nMesh2_face_ybnds:units =  degrees_north  ;\nMesh2_face_ybnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_edge_x(nMesh2_edge) ;\nMesh2_edge_x:standard_name =  longitude  ;\nMesh2_edge_x:long_name =  Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh2_edge_x:units =  degrees_east  ;\ndouble Mesh2_edge_y(nMesh2_edge) ;\nMesh2_edge_y:standard_name =  latitude  ;\nMesh2_edge_y:long_name =  Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh2_edge_y:units =  degrees_north  ;\n// bounds variables for edges skipped", 
            "title": "2D flexible mesh (mixed triangles, quadrilaterals, etc.) topology"
        }, 
        {
            "location": "/#3d-layered-mesh-topology", 
            "text": "For a 3D layered unstructured mesh topology this proposal follows the approach of the existing CF-conventions for structured meshes: horizontal and vertical dimensions are treated separately. For the horizontal plane a 2D unstructured mesh topology is defined, which is extruded in the vertical direction by means of a  vertical coordinate . The example below matches the example in the previous section combined with a vertical coordinate according CF-conventions. This example introduces also the attributes  mesh  and  location  on the 2D variables  Mesh2_surface  and  Mesh2_depth . For more information about these attributes see the  data definition  section below.   Example:  dimensions:\nnMesh2_node = 6 ; // nNodes\nnMesh2_edge = 7 ; // nEdges\nnMesh2_face = 2 ; // nFaces\nnMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace\nMesh2_layers = 10 ;\n\nTwo = 2 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\nMesh2:cf_role =  mesh_topology  ;\nMesh2:long_name =  Topology data of 2D unstructured mesh  ;\nMesh2:topology_dimension = 2 ;\nMesh2:node_coordinates =  Mesh2_node_x Mesh2_node_y  ;\nMesh2:face_node_connectivity =  Mesh2_face_nodes  ;\nMesh2:edge_node_connectivity =  Mesh2_edge_nodes  ; // attribute required if variables will be defined on edges\nMesh2:edge_coordinates =  Mesh2_edge_x Mesh2_edge_y  ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_coordinates =  Mesh2_face_x Mesh2_face_y  ; // optional attribute\nMesh2:face_edge_connectivity =  Mesh2_face_edges  ; // optional attribute (requires edge_node_connectivity)\nMesh2:face_face_connectivity =  Mesh2_face_links  ; // optional attribute\ninteger Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_nodes:cf_role =  face_node_connectivity  ;\nMesh2_face_nodes:long_name =  Maps every face to its corner nodes.  ;\nMesh2_face_nodes:_FillValue = 999999 ;\nMesh2_face_nodes:start_index = 1 ;\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\nMesh2_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh2_edge_nodes:long_name =  Maps every edge to the two nodes that it connects.  ;\nMesh2_edge_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_edges:cf_role =  face_edge_connectivity  ;\nMesh2_face_edges:long_name =  Maps every face to its edges.  ;\nMesh2_face_edges:_FillValue = 999999 ;\nMesh2_face_edges:start_index = 1 ;\ninteger Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ;\nMesh2_face_links:cf_role =  face_face_connectivity  ;\nMesh2_face_links:long_name =  Indicates which other faces neighbor each face.  ;\nMesh2_face_links:_FillValue = 999999 ;\nMesh2_face_links:start_index = 1 ;\nMesh2_face_links:flag_values = -1 ;\nMesh2_face_links:flag_meanings =  out_of_mesh  ;\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name =  longitude  ;\nMesh2_node_x:long_name =  Longitude of 2D mesh nodes.  ;\nMesh2_node_x:units =  degrees_east  ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name =  latitude  ;\nMesh2_node_y:long_name =  Latitude of 2D mesh nodes.  ;\nMesh2_node_y:units =  degrees_north  ;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name =  longitude  ;\nMesh2_face_x:long_name =  Characteristics longitude of 2D mesh face.  ;\nMesh2_face_x:units =  degrees_east  ;\nMesh2_face_x:bounds =  Mesh2_face_xbnds  ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name =  latitude  ;\nMesh2_face_y:long_name =  Characteristics latitude of 2D mesh face.  ;\nMesh2_face_y:units =  degrees_north  ;\nMesh2_face_y:bounds =  Mesh2_face_ybnds  ;\ndouble Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_xbnds:standard_name =  longitude  ;\nMesh2_face_xbnds:long_name =  Longitude bounds of 2D mesh face (i.e. corner coordinates).  ;\nMesh2_face_xbnds:units =  degrees_east  ;\nMesh2_face_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ;\nMesh2_face_ybnds:standard_name =  latitude  ;\nMesh2_face_ybnds:long_name =  Latitude bounds of 2D mesh face (i.e. corner coordinates).  ;\nMesh2_face_ybnds:units =  degrees_north  ;\nMesh2_face_ybnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_edge_x(nMesh2_edge) ;\nMesh2_edge_x:standard_name =  longitude  ;\nMesh2_edge_x:long_name =  Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh2_edge_x:units =  degrees_east  ;\ndouble Mesh2_edge_y(nMesh2_edge) ;\nMesh2_edge_y:standard_name =  latitude  ;\nMesh2_edge_y:long_name =  Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh2_edge_y:units =  degrees_north  ;\n// bounds variables for edges skipped\n\n// Vertical coordinate\ndouble Mesh2_layers(Mesh2_layers) ;\nMesh2_layers:standard_name =  ocean_sigma_coordinate  ;\nMesh2_layers:long_name =  sigma at layer midpoints  ;\nMesh2_layers:positive =  up  ;\nMesh2_layers:formula_terms =  sigma: Mesh2_layers eta: Mesh2_surface depth: Mesh2_depth  ;\ndouble Mesh2_depth(nMesh2_node) ;\nMesh2_depth:standard_name =  sea_floor_depth_below_geoid  ;\nMesh2_depth:units =  m  ;\nMesh2_depth:positive =  down  ;\nMesh2_depth:mesh =  Mesh2 \nMesh2_depth:location =  node  ;\nMesh2_depth:coordinates =  Mesh2_node_x Mesh2_node_y  ;\ndouble Mesh2_surface(nMesh2_node) ;\nMesh2_surface:standard_name =  sea_surface_height_above_geoid  ;\nMesh2_surface:units =  m  ;\nMesh2_surface:mesh =  Mesh2 \nMesh2_surface:location =  face  ;\nMesh2_surface:coordinates =  Mesh2_face_x Mesh2_face_y  ;", 
            "title": "3D layered mesh topology"
        }, 
        {
            "location": "/#fully-3d-unstructured-ie-non-layered-mesh-topology", 
            "text": "For a fully 3D unstructured mesh topology we extend the hierarchy of nodes, edges and faces to volumes. Contrary to layered case this type of mesh requires a fully 3D specification of the mesh; hence we not only need latitude and longitude coordinates but also some kind of elevation coordinate ( this probably requires a new standard name ).  The topology information is stored as attributes to a dummy variable (in the example below called  Mesh3D ) with  cf_role  mesh_topology.     Required topology attributes  Value      cf_role  mesh_topology    topology_dimension  3    node_coordinates     volume_node_connectivity     volume_shape_type     Optionally-required attributes *     face_node_connectivity     edge_node_connectivity     Optional attributes     volume_edge_connectivity     volume_face_connectivity     volume_volume_connectivity     face_edge_connectivity     boundary_node_connectivity     volume_coordinates     face_coordinates     edge_coordinates      *The  Optionally required  attributes  edge_node_connectivity  and  face_node_connectivity  are required only if you want to store data on the edges or faces respectively (i.e. if you mind the numbering order of the edges/faces).  The attribute  topology_dimension  indicates the highest dimensionality of the geometric elements; for a fully 3-dimensional unstructured mesh this should be 3. The attribute  node_coordinates  points to the auxiliary coordinate variables representing the node locations (latitude, longitude, elevation and optional other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute  volume_node_connectivity  points to an index variable identifying for every volume the indices of its corner nodes. For faces in the horizontal plane, it was possible to prescribe the order of the nodes, but this is not possible for the nodes of generic 3D volumes. For this reason we introduce an additional attribute  volume_shape_type  which points to a flag variable that specifies for every volume its shape:     flag_meaning name  description      tetrahedron  pyramid with triangular base, 4 nodes    pyramid  pyramid with square base, a pentahedron, 5 nodes    wedge  prism with triangular base, a pentahedron, 6 nodes    hexahedron  distorted cube, 8 nodes     These four volume shapes are the ones most commonly used. More shapes can be added; and if necessary, it s possible to add a generic shape type which allows for specification of the volume shape indirectly via  volume_face_connectivity  and  face_node_connectivity  variables. Such a generic shape is not included in this proposal since there is no practical need for such feature at this time.  If all volumes have the same shape type, then the shape typed could be determined based on the number of nodes per volume. Another option could be to allow the  volume_shape_type  to specify the shape type directly rather than pointing to a variable. However, for the time being we assume that the currently proposed volume shape type variable doesn t have too much impact on the performance.  The order in which the corner nodes of a volume are specified is fixed given its shape; this approach is common in 3D modeling, see e.g.  this graph in the OpenFOAM documentation  and  ParaView  or  VTK  documentation. The  volume_node_connectivity  array will be a matrix of size nVolumes x MaxNumNodesPerVolume; if a volume has less corner nodes than MaxNumNodesPerVolume then the last node indices shall be equal to  _FillValue  (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a  start_index  attribute to the index variable (i.e. Mesh3D_vol_nodes in the example below). Consistent with the CF-conventions  compression  option, the connectivity indices are 0-based by default. See  this section on zero or one-based indexing  for more details.  In case you want to define variables on the faces or edges of the 3D mesh topology you need to specify the  face_node_connectivity  or  edge_node_connectivity  attribute, respectively, to map faces or edges to nodes. Although the volume to node mapping implicitly also defines the location of the faces and edges, it does not specify their global numbering. Again the indexing convention of  face_node_connectivity  and  edge_node_connectivity  should be specified using the  start_index  attribute to the index variable and 0-based indexing is the default. Since it does not apply to either nodes or edges globally, specifying the  boundary_node_connectivity  attribute described below does not (in and of itself) necessitate the need to specify  edge_node_connectivity  nor  face_node_connectivity .  Optionally the topology may have the following attributes:   volume_face_connectivity  pointing to an index variable identifying for every volume the indices of its faces. The order in which the face indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumFacesPerVolume. If a volume has less faces than MaxNumFacesPerVolume then the last face indices shall be equal to  _FillValue , and the indexing convention of  volume_edge_connectivity  should be specified using the  start_index  attribute to the index variable and 0-based indexing is the default.   volume_edge_connectivity  pointing to an index variable identifying for every volume the indices of its edges. The order in which the edge indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumEdgesPerVolume. Again, if a volume has less edges than MaxNumEdgesPerVolume then the last edge indices shall be equal to  _FillValue , and the indexing convention of  volume_edge_connectivity  should be specified using the  start_index  attribute to the index variable and 0-based indexing is the default.   volume_volume_connectivity  pointing to an index variable identifying all volumes that share a face with each volume, i.e. are neighbors. This connectivity array will thus be a matrix of size nVolumes x MaxNumFacesPerVolume with a flag to note if the region  out of mesh  abuts a face of a given volume. Again, if a volume has less sides/faces than MaxNumFacesPerVolume then the last volume (column) indices shall be equal to  _FillValue , and the indexing convention of  volume_volume_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh3D_vol_links in the example below) and 0-based indexing is the default.   face_edge_connectivity  pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. As always, if a face has less corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to  _FillValue , and the indexing convention of  face_edge_connectivity  should be specified using the  start_index  attribute to the index variable and 0-based indexing is the default.   face_node_connectivity  pointing to an index variable identifying for every face the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to  _FillValue , and the indexing convention of  face_node_connectivity  should be specified using the  start_index  attribute to the index variable and 0-based indexing is the default.   boundary_node_connectivity  pointing to an index variable identifying for every face of each boundary the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nBoundaryFaces x MaxNumNodesPerFace. Again, if a face has less corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to  _FillValue , and the indexing convention of  boundary_node_connectivity  should be specified using the  start_index  attribute to the index variable (i.e. Mesh3D_boundary_nodes) and 0-based indexing is the default. Although constructed of faces, boundaries represent a different quantity than general face data and thus the  boundary_node_connectivity  attribute may be specified independent of  face_node_connectivity .  Information about the nature of each boundary face (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryFaces X 1.\n*  volume_coordinates ,  face_coordinates  and/or  edge_coordinates  pointing to the auxiliary coordinate variables associated with the characteristic location of the volumes, faces and edges. These auxiliary coordinate variables will have length nVolumes, nFaces and nEdges respectively, and may have in turn a  bounds  attribute that specifies the corner coordinates of the volume, face or edge (thereby duplicating the data in the  node_coordinates  variables). The order in which the corner coordinates of the volumes is given by the volume geometry type.   Example:  dimensions:\nnMesh3D_node = 12 ; // nNodes\nnMesh3D_edge = 23 ; // nEdges\nnMesh3D_face = 16 ; // nFaces\nnMesh3D_vol = 4 ; // nVolumes\nnMaxMesh3D_face_nodes = 4 ; // MaxNumNodesPerFace\nnMaxMesh3D_vol_nodes = 8 ; // MaxNumNodesPerVolume\nnMaxMesh3D_vol_edges = 12 ; // MaxNumEdgesPerVolume\nnMaxMesh3D_vol_faces = 6 ; // MaxNumFacesPerVolume\n\nTwo = 2 ;\n\nvariables:\n// Mesh topology\ninteger Mesh3D ;\nMesh3D:cf_role =  mesh_topology  ;\nMesh3D:long_name =  Topology data of 3D unstructured mesh  ;\nMesh3D:topology_dimension = 3 ;\nMesh3D:node_coordinates =  Mesh3D_node_x Mesh3D_node_y Mesh3D_node_z  ;\nMesh3D:volume_shape_type =  Mesh3D_vol_types  ;\nMesh3D:volume_node_connectivity =  Mesh3D_vol_nodes  ;\nMesh3D:face_node_connectivity =  Mesh3D_face_nodes  ; // attribute required if variables will be defined on faces\nMesh3D:edge_node_connectivity =  Mesh3D_edge_nodes  ; // attribute required if variables will be defined on edges\nMesh3D:edge_coordinates =  Mesh3D_edge_x Mesh3D_edge_y Mesh3D_edge_z  ; // optional attribute (requires edge_node_connectivity)\nMesh3D:face_coordinates =  Mesh3D_face_x Mesh3D_face_y Mesh3D_face_z  ; // optional attribute (requires face_node_connectivity)\nMesh3D:volume_coordinates =  Mesh3D_vol_x Mesh3D_vol_y Mesh3D_vol_z  ; // optional attribute\nMesh3D:volume_face_connectivity =  Mesh3D_vol_faces  ; // optional attribute (requires face_node_connectivity)\nMesh3D:volume_edge_connectivity =  Mesh3D_vol_edges  ; // optional attribute (requires edge_node_connectivity)\nMesh3D:face_edge_connectivity =  Mesh3D_face_edges  ; // optional attribute (requires face_node_connectivity and edge_node_connectivity)\nMesh3D:volume_volume_connectivity =  Mesh3D_vol_links  ; // optional attribute\ninteger Mesh3D_vol_types(nMesh3D_vol) ;\nMesh3D_vol_types:cf_role =  volume_shape_type  ;\nMesh3D_vol_types:long_name =  Specifies the shape of the individual volumes.  ;\nMesh3D_vol_types:flag_range = 0b, 2b ;\nMesh3D_vol_types:flag_values = 0b, 1b, 2b ;\nMesh3D_vol_types:flag_meanings =  tetrahedron wedge hexahedron  ;\ninteger Mesh3D_vol_nodes(nMesh3D_vol, nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_nodes:cf_role =  volume_node_connectivity  ;\nMesh3D_vol_nodes:long_name =  Maps every volume to its corner nodes.  ;\nMesh3D_vol_nodes:_FillValue = 999999 ;\nMesh3D_vol_nodes:start_index = 1 ;\n\n// Optional mesh topology variables\ninteger Mesh3D_edge_nodes(nMesh3D_edge, Two) ;\nMesh3D_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh3D_edge_nodes:long_name =  Maps every edge to the two nodes that it connects.  ;\nMesh3D_edge_nodes:start_index = 1 ;\ninteger Mesh3D_face_nodes(nMesh3D_face, nMaxMesh3D_face_nodes) ;\nMesh3D_face_nodes:cf_role =  face_node_connectivity  ;\nMesh3D_face_nodes:long_name =  Maps every face to its corner nodes.  ;\nMesh3D_face_nodes:_FillValue = 999999 ;\nMesh3D_face_nodes:start_index = 1 ;\ninteger Mesh3D_vol_faces(nMesh3D_vol, nMaxMesh3D_vol_faces) ;\nMesh3D_vol_faces:cf_role =  volume_face_connectivity  ;\nMesh3D_vol_faces:long_name =  Maps every volume to its faces.  ;\nMesh3D_vol_faces:_FillValue = 999999 ;\nMesh3D_vol_faces:start_index = 1 ;\ninteger Mesh3D_vol_edges(nMesh3D_vol, nMaxMesh3D_vol_edges) ;\nMesh3D_vol_edges:cf_role =  volume_edge_connectivity  ;\nMesh3D_vol_edges:long_name =  Maps every volume to its edges.  ;\nMesh3D_vol_edges:_FillValue = 999999 ;\nMesh3D_vol_edges:start_index = 1 ;\ninteger Mesh3D_face_edges(nMesh3D_face, nMaxMesh3D_face_nodes) ;\nMesh3D_face_edges:cf_role =  face_edge_connectivity  ;\nMesh3D_face_edges:long_name =  Maps every face to its edges.  ;\nMesh3D_face_edges:_FillValue = 999999 ;\nMesh3D_face_edges:start_index = 1 ;\ninteger Mesh3D_vol_links(nMesh3D_vol, nMaxMesh3D_vol_faces) ;\nMesh3D_vol_links:cf_role =  volume_volume_connectivity  ;\nMesh3D_vol_links:long_name =  Indicates which other volumes neighbor each volume.  ;\nMesh3D_vol_links:_FillValue = 999999 ;\nMesh3D_vol_links:start_index = 1 ;\nMesh3D_vol_links:flag_values = -1 ;\nMesh3D_vol_links:flag_meanings =  out_of_mesh  ;\n\n// Mesh node coordinates\ndouble Mesh3D_node_x(nMesh3D_node) ;\nMesh3D_node_x:standard_name =  longitude  ;\nMesh3D_node_x:long_name =  Longitude of 3D mesh nodes.  ;\nMesh3D_node_x:units =  degrees_east  ;\ndouble Mesh3D_node_y(nMesh3D_node) ;\nMesh3D_node_y:standard_name =  latitude  ;\nMesh3D_node_y:long_name =  Latitude of 3D mesh nodes.  ;\nMesh3D_node_y:units =  degrees_north  ;\ndouble Mesh3D_node_z(nMesh3D_node) ;\nMesh3D_node_z:standard_name =  elevation  ;\nMesh3D_node_z:long_name =  Elevation of 3D mesh nodes.  ;\nMesh3D_node_z:units =  m  ;\n\n// Optional mesh volume, face and edge coordinate variables\ndouble Mesh3D_vol_x(nMesh3D_vol) ;\nMesh3D_vol_x:standard_name =  longitude  ;\nMesh3D_vol_x:long_name =  Characteristics longitude of mesh volumes.  ;\nMesh3D_vol_x:units =  degrees_east  ;\nMesh3D_vol_x:bounds =  Mesh3D_vol_xbnds  ;\ndouble Mesh3D_vol_y(nMesh3D_vol) ;\nMesh3D_vol_y:standard_name =  latitude  ;\nMesh3D_vol_y:long_name =  Characteristics latitude of mesh volumes.  ;\nMesh3D_vol_y:units =  degrees_north  ;\nMesh3D_vol_y:bounds =  Mesh3D_vol_ybnds  ;\ndouble Mesh3D_vol_z(nMesh3D_vol) ;\nMesh3D_vol_z:standard_name =  elevation  ;\nMesh3D_vol_z:long_name =  Characteristics elevation of mesh volumes.  ;\nMesh3D_vol_z:units =  m  ;\nMesh3D_vol_z:bounds =  Mesh3D_vol_zbnds  ;\ndouble Mesh3D_vol_xbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_xbnds:standard_name =  longitude  ;\nMesh3D_vol_xbnds:long_name =  Longitude bounds of mesh volumes (i.e. corner coordinates).  ;\nMesh3D_vol_xbnds:units =  degrees_east  ;\nMesh3D_vol_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh3D_vol_ybnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_ybnds:standard_name =  latitude  ;\nMesh3D_vol_ybnds:long_name =  Latitude bounds of mesh volumes (i.e. corner coordinates).  ;\nMesh3D_vol_ybnds:units =  degrees_north  ;\nMesh3D_vol_ybnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh3D_vol_zbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ;\nMesh3D_vol_zbnds:standard_name =  elevation  ;\nMesh3D_vol_zbnds:long_name =  Elevation bounds of mesh volumes (i.e. corner coordinates).  ;\nMesh3D_vol_zbnds:units =  m  ;\nMesh3D_vol_zbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh3D_face_x(nMesh3D_face) ;\nMesh3D_face_x:standard_name =  longitude  ;\nMesh3D_face_x:long_name =  Characteristics longitude of mesh faces.  ;\nMesh3D_face_x:units =  degrees_east  ;\ndouble Mesh3D_face_y(nMesh3D_face) ;\nMesh3D_face_y:standard_name =  latitude  ;\nMesh3D_face_y:long_name =  Characteristics latitude of mesh faces.  ;\nMesh3D_face_y:units =  degrees_north  ;\ndouble Mesh3D_face_z(nMesh3D_face) ;\nMesh3D_face_z:standard_name =  elevation  ;\nMesh3D_face_z:long_name =  Characteristics elevation of mesh faces.  ;\nMesh3D_face_z:units =  m  ;\n// bounds variables for faces skipped\ndouble Mesh3D_edge_x(nMesh3D_edge) ;\nMesh3D_edge_x:standard_name =  longitude  ;\nMesh3D_edge_x:long_name =  Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh3D_edge_x:units =  degrees_east  ;\ndouble Mesh3D_edge_y(nMesh3D_edge) ;\nMesh3D_edge_y:standard_name =  latitude  ;\nMesh3D_edge_y:long_name =  Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh3D_edge_y:units =  degrees_north  ;\ndouble Mesh3D_edge_z(nMesh3D_edge) ;\nMesh3D_edge_z:standard_name =  latitude  ;\nMesh3D_edge_z:long_name =  Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).  ;\nMesh3D_edge_z:units =  degrees_north  ;\n// bounds variables for edges skipped", 
            "title": "Fully 3D unstructured (i.e. non-layered) mesh topology"
        }, 
        {
            "location": "/#data-defined-on-unstructured-meshes", 
            "text": "According to CF-conventions a variable defined on a  structured  mesh is specified as  double waterlevel(time,nmax,mmax) ;\nwaterlevel:standard_name =  sea_surface_height_above_geoid  ;\nwaterlevel:units =  m  ;\nwaterlevel:coordinates =  lat lon  ;  The  coordinates  attribute refers to the variables that contain the latitude and longitude coordinates. For a curvilinear grid these variables will share two spatial dimensions, here  nmax  and  mmax : lat(nmax,mmax) and lon(nmax,mmax). In numerical models the various quantities are often computed at different locations of the mesh: staggered data. The standard CF-conventions don t offer specific support for this functionality and thus for every stagger location coordinates need to be provided separately: cell center coordinates, corner point coordinates, u-flux point coordinates, and v-flux point coordinates. The underlying topology of the mesh, i.e. how these coordinates (variable definition locations) relate to each other isn t stored in the file. This shortcoming is to some degree solved by the  gridspec  proposal by  Venkatramani Balaji  and Zhi Liang. We introduce here attributes that link to the topological data defined above.", 
            "title": "Data defined on unstructured meshes"
        }, 
        {
            "location": "/#data-variables", 
            "text": "The use of the  coordinates  attribute is copied from the CF-conventions. It is used to map the values of variables defined on the unstructured meshes directly to their location: latitude, longitude and optional elevation. To map the variable onto the topology of the underlying mesh, two new attributes have been introduced. First, the attribute  mesh  points to the mesh_topology variable containing the meta-data attributes of the mesh on which the variable has been defined. Second, the attribute  location  points to the (stagger) location within the mesh at which the variable is defined. Note that in this example the  coordinates  attribute is redundant since the coordinates could also be obtained by using the  face_coordinates  attribute of the  Mesh2  variable.  double Mesh2_waterlevel(time,nMesh2_face) ;\nMesh2_waterlevel:standard_name =  sea_surface_height_above_geoid  ;\nMesh2_waterlevel:units =  m  ;\nMesh2_waterlevel:mesh =  Mesh2 \nMesh2_waterlevel:location =  face  ;\nMesh2_waterlevel:coordinates =  Mesh2_face_x Mesh2_face_y  ;", 
            "title": "Data variables"
        }, 
        {
            "location": "/#volume-and-flux-variables", 
            "text": "The same mesh geometry can be used in different ways to schematize the hydrodynamic volumes and fluxes. Let s take a simple triangular mesh. From a finite volume point of view this mesh will generally be interpreted as consisting of two volumes with triangular base. However, others may use a continuous Galerkin finite element method that can be shown to be equivalent to a subdivision into four volumes. In the former case the two faces correspond to volumes and the fluxes  cross  the edges. In the latter case the volumes are defined surrounding the four nodes and the fluxes are directed  along  the edges. The two abbreviated  ncdumps  below show how the basic 2D triangular mesh definition can be extended to include this data. The coordinate variables for the volume data now include  bounds  attributes to define the surface area of the volumes. Note the subtle difference in the long names between the flux variables in the two cases; the  standard_name  attribute has to make a more formal distinction between the two cases.     Variant 1: Volume at faces:  dimensions:\nnMesh2_node = 4 ; // nNodes\nnMesh2_edge = 5 ; // nEdges\nnMesh2_face = 2 ; // nFaces\n\nTwo = 2 ;\nThree = 3 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_nodes(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\n// as in 2D triangular mesh example\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_links(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\n// as in 2D triangular mesh example\ndouble Mesh2_node_y(nMesh2_node) ;\n// as in 2D triangular mesh example\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\nMesh2_face_x:standard_name =  longitude  ;\nMesh2_face_x:long_name =  Characteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).  ;\nMesh2_face_x:units =  degrees_east  ;\nMesh2_face_x:bounds =  Mesh2_face_xbnds  ;\ndouble Mesh2_face_y(nMesh2_face) ;\nMesh2_face_y:standard_name =  latitude  ;\nMesh2_face_y:long_name =  Characteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).  ;\nMesh2_face_y:units =  degrees_north  ;\nMesh2_face_y:bounds =  Mesh2_face_ybnds  ;\ndouble Mesh2_face_xbnds(nMesh2_face,Three) ;\nMesh2_face_xbnds:standard_name =  longitude  ;\nMesh2_face_xbnds:long_name =  Longitude bounds of 2D mesh triangle (i.e. corner coordinates).  ;\nMesh2_face_xbnds:units =  degrees_east  ;\ndouble Mesh2_face_ybnds(nMesh2_face,Three) ;\nMesh2_face_ybnds:standard_name =  latitude  ;\nMesh2_face_ybnds:long_name =  Latitude bounds of 2D mesh triangle (i.e. corner coordinates).  ;\nMesh2_face_ybnds:units =  degrees_north  ;\ndouble Mesh2_edge_x(nMesh2_edge) ;\n// as in 2D triangular mesh example\ndouble Mesh2_edge_y(nMesh2_edge) ;\n// as in 2D triangular mesh example\n\n// Volume and flux data\ndouble Mesh2_volumes(nMesh2_face) ;\nMesh2_volumes:long_name =  volumes  ;\nMesh2_volumes:units =  m3  ;\nMesh2_volumes:mesh =  Mesh2  ;\nMesh2_volumes:location =  face  ;\nMesh2_volumes:coordinates =  Mesh2_face_x Mesh2_face_y  ;\ndouble Mesh2_fluxes(nMesh2_edge) ;\nMesh2_fluxes:long_name =  flux across edge  ;\nMesh2_fluxes:units =  m3 s-1  ;\nMesh2_fluxes:mesh =  Mesh2 \nMesh2_fluxes:location =  edge  ;\nMesh2_fluxes:coordinates =  Mesh2_edge_x Mesh2_edge_y  ;  Variant 2: Volume at nodes:  dimensions:\nnMesh2_node = 4 ; // nNodes\nnMesh2_edge = 5 ; // nEdges\nnMesh2_face = 2 ; // nFaces\nnMaxMesh2_bnds = 6 ;\n\nTwo = 2 ;\nThree = 3 ;\n\nvariables:\n// Mesh topology\ninteger Mesh2 ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_nodes(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_edge_nodes(nMesh2_edge, Two) ;\n// as in 2D triangular mesh example\n\n// Optional mesh topology variables\ninteger Mesh2_face_edges(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\ninteger Mesh2_face_links(nMesh2_face, Three) ;\n// as in 2D triangular mesh example\n\n// Mesh node coordinates\ndouble Mesh2_node_x(nMesh2_node) ;\nMesh2_node_x:standard_name =  longitude  ;\nMesh2_node_x:long_name =  Longitude of 2D mesh nodes.  ;\nMesh2_node_x:units =  degrees_east  ;\nMesh2_node_x:bounds =  Mesh2_node_xbnds  ;\ndouble Mesh2_node_y(nMesh2_node) ;\nMesh2_node_y:standard_name =  latitude  ;\nMesh2_node_y:long_name =  Latitude of 2D mesh nodes.  ;\nMesh2_node_y:units =  degrees_north  ;\nMesh2_node_y:bounds =  Mesh2_node_ybnds  ;\ndouble Mesh2_node_xbnds(nMesh2_node, nMaxMesh2_bnds) ;\nMesh2_node_xbnds:standard_name =  longitude  ;\nMesh2_node_xbnds:long_name =  List of x-points that form outline of flow volume  ;\nMesh2_node_xbnds:units =  degrees_east  ;\nMesh2_node_xbnds:_FillValue = 9.9692099683868690E36;\ndouble Mesh2_node_ybnds(nMesh2_node, nMaxMesh2_bnds) ;\nMesh2_node_ybnds:standard_name =  latitude  ;\nMesh2_node_ybnds:units =  degrees_north  ;\nMesh2_node_ybnds:long_name =  List of y-points that form outline of flow volume  ;\nMesh2_node_xbnds:_FillValue = 9.9692099683868690E36;\n\n// Optional mesh face and edge coordinate variables\ndouble Mesh2_face_x(nMesh2_face) ;\n// as in 2D triangular mesh example\ndouble Mesh2_face_y(nMesh2_face) ;\n// as in 2D triangular mesh example\ndouble Mesh2_edge_x(nMesh2_edge) ;\n// as in 2D triangular mesh example\ndouble Mesh2_edge_y(nMesh2_edge) ;\n// as in 2D triangular mesh example\n\n// Volume and flux data\ndouble Mesh2_volumes(nMesh2_node) ;\nMesh2_volumes:long_name =  volumes  ;\nMesh2_volumes:units =  m3  ;\nMesh2_volumes:mesh =  Mesh2  ;\nMesh2_volumes:location =  node  ;\nMesh2_volumes:coordinates =  Mesh2_node_x Mesh2_node_y  ;\ndouble Mesh2_fluxes(nMesh2_edge) ;\nMesh2_fluxes:long_name =  flux along edge  ;\nMesh2_fluxes:units =  m3 s-1  ;\nMesh2_fluxes:mesh =  Mesh2 \nMesh2_fluxes:location =  edge  ;\nMesh2_fluxes:coordinates =  Mesh2_edge_x Mesh2_edge_y  ;", 
            "title": "Volume and flux variables"
        }, 
        {
            "location": "/#location-index-set", 
            "text": "Some variables may only be defined at specific locations within the mesh, e.g. only at boundary points or at special locations like weirs and gates. To save space and to improve readability, the concept of a location_index_set is introduced. It is basically identical to the  compression  option in the the CF-conventions except for the fact that the compression works on a (set of) orthogonal coordinate dimension(s) and the location_index_set works on a topology location.  The location index set is an integer variable that contains the indices of the locations at which a specific quantity is defined. The example below defines a location index set  Mesh1_set  as a subset of the  node s of Mesh1 (red points). The attribute  location_index_set  of the variable  Mesh_waterlevel  points to this index set and the  coordinates  attribute points to the corresponding (subset) of latitude and longitude coordinates. The  mesh  and  location  attributes of the location_index_set variable are required; the  coordinates  attribute is optional. Note that the  coordinates  attributes on both  Mesh1_cell  and  Mesh1_waterlevel  are again redundant since the coordinates could also be obtained by using the index set  Mesh1_set  and the  node_coordinates  attribute of the  Mesh1  variable. Consistent with all other index variables defined here, the indexing convention of the location index set should be specified using the  start_index  attribute to the index variable and 0-based indexing is the default. See  this section on zero or one-based indexing  for more details.  Contrary to a coordinate variable, the index set doesn t have to be monotonic. So, it can be used for creating subsets of the original locations as well as for renumbering the locations. If the  location_index_set  attribute is used on a variable, then the  mesh  and  location  attributes should not also be used on that variable.   dimensions:\nnMesh1_set = 4 ;\n\nvariables:\ninteger Mesh1_set(nMesh1_set) ;\nMesh1_set:cf_role =  location_index_set  ;\nMesh1_set:long_name =  Defines Mesh1_set as subset of the nodes of Mesh1.  ;\nMesh1_set:mesh =  Mesh1  ;\nMesh1_set:location =  node  ;\nMesh1_set:start_index = 1 ;\nMesh1_set:coordinates =  Mesh1_set_x Mesh1_set_y  ;\ndouble Mesh1_set_x(nMesh1_set) ;\nMesh1_set_x:standard_name =  longitude  ;\nMesh1_set_x:long_name =  Characteristic longitude of set (e.g. longitude of node).  ;\nMesh1_set_x:units =  degrees_east  ;\ndouble Mesh1_set_y(nMesh1_set) ;\nMesh1_set_y:standard_name =  latitude  ;\nMesh1_set_y:long_name =  Characteristic latitude of set (e.g. latitude of node)  ;\nMesh1_set_y:units =  degrees_north  ;\n\ndouble Mesh1_waterlevel(time, nMesh1_set) ;\nMesh1_waterlevel:standard_name =  sea_surface_height_above_geoid  ;\nMesh1_waterlevel:units =  m  ;\nMesh1_waterlevel:location_index_set =  Mesh1_set  ;\nMesh1_waterlevel:coordinates =  Mesh1_set_x Mesh1_set_y  ;", 
            "title": "Location index set"
        }, 
        {
            "location": "/#zero-or-one-based-indexing", 
            "text": "The indexing using by the CF  compression  option is 0-based. Therefore, it is most consistent for this CF extension for unstructured data to also use 0-based indexing, which means that points, edges, faces and volumes will be numbered starting with 0. This convention is consistent with languages like C and Java, but unlike Fortran and MATLAB. Since many of the unstructured models have been programmed in Fortran and legacy NetCDF files exist that use 1-based indexing (which could be upgraded to be consistent with this new proposal using ncML if 1-based indexing were allowed), we propose to support both 0- and 1-based indexing by means of the  start_index  attribute. You will find below two examples of the same network geometry using either 0- or 1-based indexing. Switching between 0- and 1-based indexing is as easy as adding 1 to or subtracting 1 from the indices upon reading or writing depending on the setting of  start_index ; allowing both options should only have a minor impact on the reading routines and no effect at all on the rest of your code.  Example of 0-based indexing:   dimensions:\nnMesh1_node = 5 ; // nNodes\nnMesh1_edge = 4 ; // nEdges\n\nTwo = 2;\n\nvariables:\n// Mesh topology\ninteger Mesh1 ;\nMesh1:cf_role =  mesh_topology  ;\nMesh1:long_name =  Topology data of 1D network  ;\nMesh1:topology_dimension = 1 ;\nMesh1:node_coordinates =  Mesh1_node_x Mesh1_node_y  ;\nMesh1:edge_node_connectivity =  Mesh1_edge_nodes  ;\nMesh1:edge_coordinates =  Mesh1_edge_x Mesh1_edge_y  ; // optional attribute\ninteger Mesh1_edge_nodes(nMesh1_edge, Two) ;\nMesh1_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh1_edge_nodes:long_name =  Maps every edge/link to the two nodes that it connects.  ;\nMesh1_edge_nodes:start_index = 0 ; // default setting, attribute could have been skipped.\n\n// Coordinate variables skipped\n\ndata:\n\nMesh1 = 0 ; // dummy\n\nMesh1_edge_nodes =\n0, 2,\n1, 2,\n2, 3,\n3, 4 ;  Example of 1-based indexing:   dimensions:\nnMesh1_node = 5 ; // nNodes\nnMesh1_edge = 4 ; // nEdges\n\nTwo = 2;\n\nvariables:\n// Mesh topology\ninteger Mesh1 ;\nMesh1:cf_role =  mesh_topology  ;\nMesh1:long_name =  Topology data of 1D network  ;\nMesh1:topology_dimension = 1 ;\nMesh1:node_coordinates =  Mesh1_node_x Mesh1_node_y  ;\nMesh1:edge_node_connectivity =  Mesh1_edge_nodes  ;\nMesh1:edge_coordinates =  Mesh1_edge_x Mesh1_edge_y  ; // optional attribute\ninteger Mesh1_edge_nodes(nMesh1_edge, Two) ;\nMesh1_edge_nodes:cf_role =  edge_node_connectivity  ;\nMesh1_edge_nodes:long_name =  Maps every edge/link to the two nodes that it connects.  ;\nMesh1_edge_nodes:start_index = 1 ;\n\n// Coordinate variables skipped\n\ndata:\n\nMesh1 = 0 ; // dummy\n\nMesh1_edge_nodes =\n1, 3,\n2, 3,\n3, 4,\n4, 5 ;", 
            "title": "Zero or One-based indexing"
        }, 
        {
            "location": "/ugrid-subsetting/", 
            "text": "UGRID Subsetting\n\uf0c1\n\n\nIntroduction\n\uf0c1\n\n\nThis project, and accompanying document, are all about a NetCDF standard for describing unstructured grids and the data/model results stored on them. Having such a standard is key to interoperability between different modeling systems and post-processing tools, etc. And once NetCDF is supported that access protocols like Open-source Project for a Network Data Access Protocol (OPeNDAP) can be used.\n\n\nHowever, there is an additional challenge. Modern unstructured grid models can use very large grids, and thus produce extremely large results sets. However, a particular client application may only need a spatial subset of that data. Ideally, there would be a way for a client to download only the portion of the model domain required.\n\n\nWith structured grids, you can make good use of OPeNDAP\ns ability to slice arrays to get a subset of the data that is useful. However, with UGRIDs, data in a contiguous region in the spatial domain is generally not contiguous in the data arrays. So to do subsetting, the system needs to understand the topology of the grid, and select the appropriate discontiguous subset of the data and grid, and put all that together into a still-correct UGRID dataset.\n\n\nThis can be done on the client side, figuring out the grid geometry and requesting the required data via OPeNDAP. However, OPeNDAP does not support requesting discontiguous data, so it is necessary to make many small requests to the server and put it back together on the client. This not only means a lot of complex client-side code, but it\ns also painfully slow to do many small requests, rather than one large one. In fact, with some testing, for anything but tiny subsets, it\ns faster to grab the entire grid than do many small requests for a subset.\n\n\nOPeNDAP subsetting protocol\n\uf0c1\n\n\nTo address this issue, OPeNDAP, Inc., under a grant from NOAA, has developed an extension to the Hyrax server that supports server-side subsetting of UGRIDs via OPeNDAP server-side functions. As the implementation uses the existing OPeNDAP server-side function protocol, it should be usable with standard OPeNDAP clients, and it should be possible to implement the functionally with the same application programming interface (API), in any OPeNDAP server.\n\n\nDocumentation of the server-side function API is here:\n\n\nUGRID subsetting docs\n\n\nHyrax implementation\n\uf0c1\n\n\nRecent development builds of Hyrax include the new functionality, so it should be available in the next Hyrax release.\n\n\nThe source code for the Hyrax implementation is here:\n\n\nHyrax subsetting code\n\n\nGridFields\n\uf0c1\n\n\nThe subsetting code in the Hyrax server is implemented by the \nGridFields\n library. The source code for the version of GridFields can be found here:\n\n\nGridFields source\n\n\nThe GridFields library has a much broader scope of capabilities than is utilized with this simple subsetting function, and could be used for a number of other UGRID-manipulating and evaluating tasks.\n\n\nOther OPeNDAP servers.\n\uf0c1\n\n\nAs of this writing, I am unaware of any other implementations of server-side subsetting in an OPeNDAP server. However it is hoped that other OPeNDAP servers will add such functionality eventually, and hopefully using the same API, as documented by the document linked to above.\n\n\nGridfields is written in C++, and thus could be used with any other server that can call C++. It also has Python bindings, and thus could be used with a Python implementation, such as \nPyDAP\n.\n\n\nAlternatively, the same functionality could be implemented with a different library for the subsetting code itself. Perhaps a Java library for use with the \nTHREDDS\n server.", 
            "title": "subsetting"
        }, 
        {
            "location": "/ugrid-subsetting/#ugrid-subsetting", 
            "text": "", 
            "title": "UGRID Subsetting"
        }, 
        {
            "location": "/ugrid-subsetting/#introduction", 
            "text": "This project, and accompanying document, are all about a NetCDF standard for describing unstructured grids and the data/model results stored on them. Having such a standard is key to interoperability between different modeling systems and post-processing tools, etc. And once NetCDF is supported that access protocols like Open-source Project for a Network Data Access Protocol (OPeNDAP) can be used.  However, there is an additional challenge. Modern unstructured grid models can use very large grids, and thus produce extremely large results sets. However, a particular client application may only need a spatial subset of that data. Ideally, there would be a way for a client to download only the portion of the model domain required.  With structured grids, you can make good use of OPeNDAP s ability to slice arrays to get a subset of the data that is useful. However, with UGRIDs, data in a contiguous region in the spatial domain is generally not contiguous in the data arrays. So to do subsetting, the system needs to understand the topology of the grid, and select the appropriate discontiguous subset of the data and grid, and put all that together into a still-correct UGRID dataset.  This can be done on the client side, figuring out the grid geometry and requesting the required data via OPeNDAP. However, OPeNDAP does not support requesting discontiguous data, so it is necessary to make many small requests to the server and put it back together on the client. This not only means a lot of complex client-side code, but it s also painfully slow to do many small requests, rather than one large one. In fact, with some testing, for anything but tiny subsets, it s faster to grab the entire grid than do many small requests for a subset.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ugrid-subsetting/#opendap-subsetting-protocol", 
            "text": "To address this issue, OPeNDAP, Inc., under a grant from NOAA, has developed an extension to the Hyrax server that supports server-side subsetting of UGRIDs via OPeNDAP server-side functions. As the implementation uses the existing OPeNDAP server-side function protocol, it should be usable with standard OPeNDAP clients, and it should be possible to implement the functionally with the same application programming interface (API), in any OPeNDAP server.  Documentation of the server-side function API is here:  UGRID subsetting docs", 
            "title": "OPeNDAP subsetting protocol"
        }, 
        {
            "location": "/ugrid-subsetting/#hyrax-implementation", 
            "text": "Recent development builds of Hyrax include the new functionality, so it should be available in the next Hyrax release.  The source code for the Hyrax implementation is here:  Hyrax subsetting code", 
            "title": "Hyrax implementation"
        }, 
        {
            "location": "/ugrid-subsetting/#gridfields", 
            "text": "The subsetting code in the Hyrax server is implemented by the  GridFields  library. The source code for the version of GridFields can be found here:  GridFields source  The GridFields library has a much broader scope of capabilities than is utilized with this simple subsetting function, and could be used for a number of other UGRID-manipulating and evaluating tasks.", 
            "title": "GridFields"
        }, 
        {
            "location": "/ugrid-subsetting/#other-opendap-servers", 
            "text": "As of this writing, I am unaware of any other implementations of server-side subsetting in an OPeNDAP server. However it is hoped that other OPeNDAP servers will add such functionality eventually, and hopefully using the same API, as documented by the document linked to above.  Gridfields is written in C++, and thus could be used with any other server that can call C++. It also has Python bindings, and thus could be used with a Python implementation, such as  PyDAP .  Alternatively, the same functionality could be implemented with a different library for the subsetting code itself. Perhaps a Java library for use with the  THREDDS  server.", 
            "title": "Other OPeNDAP servers."
        }
    ]
}